; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33135.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6628E330_concurrencysal@h DB 01H
__DD735C24_sal@h DB 01H
__95D07812_vadefs@h DB 01H
__2C966F75_vcruntime@h DB 01H
__C84B2A68_xkeycheck@h DB 01H
__E4981F91_yvals_core@h DB 01H
__1B0272D9_corecrt@h DB 01H
__50BF2FAA_vcruntime_new@h DB 01H
__973DD6D2_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__EA84BEDA_crtdefs@h DB 01H
__7A2C09FE_use_ansi@h DB 01H
__B806B4B7_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__099E6B1A_cstdio DB 01H
__8ECB7138_corecrt_share@h DB 01H
__F7972D0B_share@h DB 01H
__13F5961F_stddef@h DB 01H
__81223BB7_xtr1common DB 01H
__AB8DD8A5_cstddef DB 01H
__C9486F03___msvc_system_error_abi@hpp DB 01H
__61CC25A1_errno@h DB 01H
__94BF1FE1_cerrno DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__53AB384B_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__0E460208_cstdlib DB 01H
__EDDD1674_stdint@h DB 01H
__B318E375_cstdint DB 01H
__86E2ECA3_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__597317E9_eh@h DB 01H
__9FD3D380_vcruntime_exception@h DB 01H
__22DBD04C_exception DB 01H
__FFDAFD70___msvc_sanitizer_annotate_container@hpp DB 01H
__21B98AC3_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__42D4AAE8_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__9315BD49_cwchar DB 01H
__D0D5387F_iosfwd DB 01H
__B9985323_float@h DB 01H
__7ADAA09D_cfloat DB 01H
__8AA920FA_climits DB 01H
__2FEC17FD_intrin0@inl@h DB 01H
__F3A907D1_intrin0@h DB 01H
__1C3CEDF9_limits DB 01H
__6B6686E8_new DB 01H
__28D75C9A_xatomic@h DB 01H
__7CEE9503_initializer_list DB 01H
__05AD8743_concepts DB 01H
__F75338B9_compare DB 01H
__394B8783_utility DB 01H
__6CD66C6A___msvc_iter_core@hpp DB 01H
__81056E89_xutility DB 01H
__19EA4BD2_tuple DB 01H
__53DEE440_xmemory DB 01H
__C1E54F69_xpolymorphic_allocator@h DB 01H
__270D62DC_xstring DB 01H
__AB95EA11_stdexcept DB 01H
__A700C1C1_xcall_once@h DB 01H
__1093A1B8_xerrc@h DB 01H
__8E83AFDB_xatomic_wait@h DB 01H
__0A9237D2_time@h DB 01H
__797ACE9B_ctime DB 01H
__37C18DC8_xtimec@h DB 01H
__1B623E4D_xthreads@h DB 01H
__7709B13B_atomic DB 01H
__185DD3E1_system_error DB 01H
__78388AF5_vcruntime_typeinfo@h DB 01H
__F1DA9D90_typeinfo DB 01H
__A092E177_memory DB 01H
__8CD7B678_xfacet DB 01H
__8B91FF0A___msvc_xlocinfo_types@hpp DB 01H
__1EC467ED_ctype@h DB 01H
__06558CBD_cctype DB 01H
__791C33B7_locale@h DB 01H
__9DEADED9_clocale DB 01H
__EE537E58_xlocinfo DB 01H
__F83316ED_xlocale DB 01H
__D7B6094B_xiosbase DB 01H
__A93552AD_streambuf DB 01H
__AD982FC2___msvc_filebuf@hpp DB 01H
__BFC95293_cmath DB 01H
__90A9D9C9_iterator DB 01H
__66B470FA_xlocnum DB 01H
__93ABBCFE_ios DB 01H
__EB23CC29_ostream DB 01H
__88F3F913_istream DB 01H
__7EBB89FA_fstream DB 01H
__C8179298_algorithm DB 01H
__D37ACB3D_ratio DB 01H
__368A71EB___msvc_chrono@hpp DB 01H
__DE87ED23_xfilesystem_abi@h DB 01H
__EA190C3F___msvc_tzdb@hpp DB 01H
__23BB31BF_forward_list DB 01H
__863D0478_xsmf_control@h DB 01H
__E8D1C288_optional DB 01H
__D44167EB_string DB 01H
__4B5D3A93_sstream DB 01H
__187EA84C___msvc_bit_utils@hpp DB 01H
__51919D19_vector DB 01H
__4A4ED74A_xloctime DB 01H
__C8CB7150___msvc_format_ucd_tables@hpp DB 01H
__A07C8C4C___msvc_print@hpp DB 01H
__57C0613A_bit DB 01H
__AE686A70_xbit_ops@h DB 01H
__82C730B3_xcharconv@h DB 01H
__D48FA755_xcharconv_ryu_tables@h DB 01H
__4AEC53CD_xcharconv_ryu@h DB 01H
__E350A92B_xcharconv_tables@h DB 01H
__9E8A00EF_charconv DB 01H
__F87C5016_xlocbuf DB 01H
__D43FE191_xlocmes DB 01H
__4DD665C2_xlocmon DB 01H
__0B7F13DA_locale DB 01H
__9445A79D_format DB 01H
__74313F41_iomanip DB 01H
__78D1EB73_chrono DB 01H
__77C0A0AD_filesystem DB 01H
__E37C1496_iostream DB 01H
__6E434CEF_vcruntime_startup@h DB 01H
__005E73E1_corecrt_startup@h DB 01H
__8B12B2C4_process@h DB 01H
__4CE3A781_stop_token DB 01H
__7BDF99C1_thread DB 01H
__B3D148E0_deque DB 01H
__50E70C21_queue DB 01H
__C1D7C16D_mutex DB 01H
__3EAD4D02_list DB 01H
__DA916AFB_xnode_handle@h DB 01H
__D06692F5_xhash DB 01H
__43E0D473_unordered_map DB 01H
__7931BFA6_functional DB 01H
__82DE502A_includes@h DB 01H
__EB3D323B_thread_pool@h DB 01H
__870AB2AE_thread_pool@cpp DB 01H
__6A59E0E5_predefined C++ types (compiler internal) DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	wmemcpy
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPEA_WPEB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??1thread@std@@QEAA@XZ				; std::thread::~thread
PUBLIC	??0thread@std@@QEAA@$$QEAV01@@Z			; std::thread::thread
PUBLIC	?joinable@thread@std@@QEBA_NXZ			; std::thread::joinable
PUBLIC	?join@thread@std@@QEAAXXZ			; std::thread::join
PUBLIC	??_Gthread@std@@QEAAPEAXI@Z			; std::thread::`scalar deleting destructor'
PUBLIC	??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z ; std::exchange<_Thrd_t,_Thrd_t>
PUBLIC	??0_Mutex_base@std@@QEAA@H@Z			; std::_Mutex_base::_Mutex_base
PUBLIC	??1_Mutex_base@std@@QEAA@XZ			; std::_Mutex_base::~_Mutex_base
PUBLIC	?lock@_Mutex_base@std@@QEAAXXZ			; std::_Mutex_base::lock
PUBLIC	?unlock@_Mutex_base@std@@QEAAXXZ		; std::_Mutex_base::unlock
PUBLIC	?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ ; std::_Mutex_base::_Verify_ownership_levels
PUBLIC	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
PUBLIC	??0mutex@std@@QEAA@XZ				; std::mutex::mutex
PUBLIC	??1mutex@std@@QEAA@XZ				; std::mutex::~mutex
PUBLIC	??0condition_variable@std@@QEAA@XZ		; std::condition_variable::condition_variable
PUBLIC	??1condition_variable@std@@QEAA@XZ		; std::condition_variable::~condition_variable
PUBLIC	?notify_one@condition_variable@std@@QEAAXXZ	; std::condition_variable::notify_one
PUBLIC	?notify_all@condition_variable@std@@QEAAXXZ	; std::condition_variable::notify_all
PUBLIC	?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z ; std::condition_variable::wait
PUBLIC	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
PUBLIC	??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
PUBLIC	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ	; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
PUBLIC	?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ ; std::unique_lock<std::mutex>::mutex
PUBLIC	?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z ; std::unique_lock<std::mutex>::__autoclassinit2
PUBLIC	??0thread_pool@@QEAA@_K@Z			; thread_pool::thread_pool
PUBLIC	??1thread_pool@@QEAA@XZ				; thread_pool::~thread_pool
PUBLIC	?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z ; thread_pool::enqueue
PUBLIC	??0?$allocator@Vthread@std@@@std@@QEAA@XZ	; std::allocator<std::thread>::allocator<std::thread>
PUBLIC	?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z ; std::allocator<std::thread>::deallocate
PUBLIC	?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z ; std::allocator<std::thread>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::max_size
PUBLIC	??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ; std::vector<std::thread,std::allocator<std::thread> >::vector<std::thread,std::allocator<std::thread> >
PUBLIC	??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
PUBLIC	?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_end
PUBLIC	?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ; std::vector<std::thread,std::allocator<std::thread> >::max_size
PUBLIC	?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ; std::vector<std::thread,std::allocator<std::thread> >::capacity
PUBLIC	?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Change_array
PUBLIC	?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ ; std::vector<std::thread,std::allocator<std::thread> >::_Tidy
PUBLIC	?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ ; std::vector<std::thread,std::allocator<std::thread> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range
PUBLIC	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
PUBLIC	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::thread> >::_Vector_val<std::_Simple_types<std::thread> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first
PUBLIC	??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
PUBLIC	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate
PUBLIC	?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
PUBLIC	?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> *>::deallocate
PUBLIC	?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> *>::allocate
PUBLIC	??0?$_Func_class@X$$V@std@@QEAA@XZ		; std::_Func_class<void>::_Func_class<void>
PUBLIC	??R?$_Func_class@X$$V@std@@QEBAXXZ		; std::_Func_class<void>::operator()
PUBLIC	??1?$_Func_class@X$$V@std@@QEAA@XZ		; std::_Func_class<void>::~_Func_class<void>
PUBLIC	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ	; std::_Func_class<void>::_Empty
PUBLIC	?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ; std::_Func_class<void>::_Reset_copy
PUBLIC	?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ; std::_Func_class<void>::_Reset_move
PUBLIC	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ		; std::_Func_class<void>::_Tidy
PUBLIC	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ	; std::_Func_class<void>::_Local
PUBLIC	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
PUBLIC	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
PUBLIC	??0?$function@$$A6AXXZ@std@@QEAA@XZ		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z ; std::function<void __cdecl(void)>::operator=
PUBLIC	??1?$function@$$A6AXXZ@std@@QEAA@XZ		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
PUBLIC	??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z	; std::function<void __cdecl(void)>::`scalar deleting destructor'
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Getblock
PUBLIC	??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
PUBLIC	?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
PUBLIC	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
PUBLIC	?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::front
PUBLIC	?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_front
PUBLIC	?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back
PUBLIC	?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_back
PUBLIC	?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlen
PUBLIC	?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
PUBLIC	?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
PUBLIC	?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off
PUBLIC	?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock
PUBLIC	?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_all
PUBLIC	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
PUBLIC	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
PUBLIC	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
PUBLIC	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
PUBLIC	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
PUBLIC	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
PUBLIC	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
PUBLIC	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
PUBLIC	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
PUBLIC	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
PUBLIC	??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
PUBLIC	?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::empty
PUBLIC	?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::front
PUBLIC	?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::push
PUBLIC	?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pop
PUBLIC	??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
PUBLIC	?worker@thread_pool@@AEAAXXZ			; thread_pool::worker
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::function<void __cdecl(void)> >
PUBLIC	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1><>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> >
PUBLIC	??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::thread>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1><>
PUBLIC	??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z ; std::addressof<std::mutex>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::function<void __cdecl(void)> *>::allocator<std::function<void __cdecl(void)> *><std::function<void __cdecl(void)> >
PUBLIC	??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_Destroy_in_place<std::function<void __cdecl(void)> *>
PUBLIC	??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_internal<std::function<void __cdecl(void)> const &>
PUBLIC	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
PUBLIC	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread> >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>
PUBLIC	??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z ; std::destroy_at<std::function<void __cdecl(void)> >
PUBLIC	??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ; std::_Unfancy<std::thread>
PUBLIC	??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::destroy<std::thread>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> *> >
PUBLIC	??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>
PUBLIC	??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ; std::_Destroy_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z		; std::_Get_size_of_n<64>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::thread> >
PUBLIC	??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z ; std::construct_at<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &,0>
PUBLIC	??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z ; std::destroy_at<std::thread>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Adl_verify_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * * const &>
PUBLIC	??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Idl_distance<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z ; std::_Get_unwrapped_n<std::function<void __cdecl(void)> * * &,__int64>
PUBLIC	??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z ; std::_Seek_wrapped<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z ; std::_Zero_range<std::function<void __cdecl(void)> * *>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z ; std::_Get_unwrapped<std::thread * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Uninitialized_backout_al<std::allocator<std::thread> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::~_Uninitialized_backout_al<std::allocator<std::thread> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::__autoclassinit2
PUBLIC	??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Emplace_back<std::thread>
PUBLIC	??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z ; std::_Verify_range<std::function<void __cdecl(void)> *>
PUBLIC	??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z ; std::_Copy_memmove<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
PUBLIC	??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Uninitialized_backout<std::function<void __cdecl(void)> * *>
PUBLIC	??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::~_Uninitialized_backout<std::function<void __cdecl(void)> * *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Release
PUBLIC	??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Emplace_back<std::function<void __cdecl(void)> * &>
PUBLIC	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
PUBLIC	??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ; std::to_address<std::function<void __cdecl(void)> *>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,std::thread>
PUBLIC	??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Construct_in_place<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &>
PUBLIC	??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::thread,std::thread,0>
PUBLIC	??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> *>
PUBLIC	??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z ; std::construct_at<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &,0>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0GC@GNDJPOJH@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	?__LINE__Var@?0??_Maklocwcs@std@@YAPEA_WPEB_W@Z@4JA ; `std::_Maklocwcs'::`1'::__LINE__Var
PUBLIC	??_C@_0GC@OOHEPMDG@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GD@OFOHMBDA@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MG@OMEADHM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@	; `string'
PUBLIC	??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@ ; `string'
PUBLIC	??_C@_0BO@PEOHNLIM@front?$CI?$CJ?5called?5on?5empty?5deque@ ; `string'
PUBLIC	??_C@_1EA@EELNAHHD@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__calloc_dbg:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp_terminate:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__imp_wcslen:PROC
EXTRN	strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	_Thrd_join:PROC
EXTRN	_Thrd_id:PROC
EXTRN	_Mtx_init_in_situ:PROC
EXTRN	_Mtx_destroy_in_situ:PROC
EXTRN	_Mtx_lock:PROC
EXTRN	_Mtx_unlock:PROC
EXTRN	_Cnd_init_in_situ:PROC
EXTRN	_Cnd_destroy_in_situ:PROC
EXTRN	_Cnd_wait:PROC
EXTRN	_Cnd_broadcast:PROC
EXTRN	_Cnd_signal:PROC
EXTRN	_Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	_Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	?_Xbad_function_call@std@@YAXXZ:PROC		; std::_Xbad_function_call
EXTRN	_CxxThrowException:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??2@YAPEAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+123
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcpy DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$wmemcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max@?$numeric_limits@_J@std@@SA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?max@?$numeric_limits@_J@std@@SA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+453
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??0_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z DD imagerel $LN12
	DD	imagerel $LN12+586
	DD	imagerel $unwind$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Maklocwcs@std@@YAPEA_WPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+142
	DD	imagerel $unwind$?_Maklocwcs@std@@YAPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD imagerel $LN7
	DD	imagerel $LN7+200
	DD	imagerel $unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+356
	DD	imagerel $unwind$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+356
	DD	imagerel $unwind$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1thread@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??1thread@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0thread@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$??0thread@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?joinable@thread@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?joinable@thread@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?join@thread@std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+194
	DD	imagerel $unwind$?join@thread@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gthread@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??_Gthread@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Mutex_base@std@@QEAA@H@Z DD imagerel $LN3
	DD	imagerel $LN3+189
	DD	imagerel $unwind$??0_Mutex_base@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Mutex_base@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$??1_Mutex_base@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?lock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?unlock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0mutex@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??0mutex@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1mutex@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??1mutex@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0condition_variable@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??0condition_variable@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1condition_variable@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$??1condition_variable@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?notify_one@condition_variable@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?notify_one@condition_variable@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?notify_all@condition_variable@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?notify_all@condition_variable@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0thread_pool@@QEAA@_K@Z DD imagerel $LN10
	DD	imagerel $LN10+229
	DD	imagerel $unwind$??0thread_pool@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA DD imagerel ?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA DD imagerel ?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA+43
	DD	imagerel $unwind$?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA DD imagerel ?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA+43
	DD	imagerel $unwind$?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA DD imagerel ?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA+46
	DD	imagerel $unwind$?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1thread_pool@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+375
	DD	imagerel $unwind$??1thread_pool@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+238
	DD	imagerel $unwind$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA DD imagerel ?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA DD imagerel ?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA+36
	DD	imagerel $unwind$?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@Vthread@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0?$allocator@Vthread@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+213
	DD	imagerel $unwind$?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+203
	DD	imagerel $unwind$??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+168
	DD	imagerel $unwind$?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+280
	DD	imagerel $unwind$?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+228
	DD	imagerel $unwind$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD imagerel $LN8
	DD	imagerel $LN8+173
	DD	imagerel $unwind$?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD imagerel $LN4
	DD	imagerel $LN4+177
	DD	imagerel $unwind$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA DD imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA
	DD	imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA+37
	DD	imagerel $unwind$?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+213
	DD	imagerel $unwind$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+216
	DD	imagerel $unwind$?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Func_class@X$$V@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??0?$_Func_class@X$$V@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@X$$V@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$??R?$_Func_class@X$$V@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Func_class@X$$V@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Func_class@X$$V@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+142
	DD	imagerel $unwind$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z DD imagerel $LN6
	DD	imagerel $LN6+221
	DD	imagerel $unwind$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+169
	DD	imagerel $unwind$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$function@$$A6AXXZ@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0?$function@$$A6AXXZ@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$function@$$A6AXXZ@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??1?$function@$$A6AXXZ@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+153
	DD	imagerel $unwind$??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+200
	DD	imagerel $unwind$??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN12
	DD	imagerel $LN12+206
	DD	imagerel $unwind$?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+456
	DD	imagerel $unwind$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+420
	DD	imagerel $unwind$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+1088
	DD	imagerel $unwind$?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+488
	DD	imagerel $unwind$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z DD imagerel $LN11
	DD	imagerel $LN11+401
	DD	imagerel $unwind$?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?worker@thread_pool@@AEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+380
	DD	imagerel $unwind$?worker@thread_pool@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA+36
	DD	imagerel $unwind$?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA+36
	DD	imagerel $unwind$?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ DD imagerel ??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ
	DD	imagerel ??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ+56
	DD	imagerel $unwind$??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z DD imagerel ??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z
	DD	imagerel ??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z+70
	DD	imagerel $unwind$??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+73
	DD	imagerel $unwind$??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+133
	DD	imagerel $unwind$??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ DD imagerel ??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ
	DD	imagerel ??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ+120
	DD	imagerel $unwind$??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z DD imagerel ??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z
	DD	imagerel ??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z+70
	DD	imagerel $unwind$??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z DD imagerel ??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z
	DD	imagerel ??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z+91
	DD	imagerel $unwind$??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+213
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+561
	DD	imagerel $unwind$??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+192
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+644
	DD	imagerel $unwind$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA+91
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+263
	DD	imagerel $unwind$??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+72
	DD	imagerel $unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+70
	DD	imagerel $unwind$??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+276
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN13
	DD	imagerel $LN13+277
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z DD imagerel $LN8
	DD	imagerel $LN8+273
	DD	imagerel $unwind$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+89
	DD	imagerel $unwind$??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z DD imagerel $LN12
	DD	imagerel $LN12+181
	DD	imagerel $unwind$??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z DD imagerel $LN3
	DD	imagerel $LN3+196
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+293
	DD	imagerel $unwind$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA DD imagerel ?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+163
	DD	imagerel $unwind$??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD imagerel ??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
	DD	imagerel ??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z+125
	DD	imagerel $unwind$??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ DD imagerel ??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ
	DD	imagerel ??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ+112
	DD	imagerel $unwind$??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ DD imagerel ?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
	DD	imagerel ?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ+51
	DD	imagerel $unwind$?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ DD imagerel ?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
	DD	imagerel ?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ+74
	DD	imagerel $unwind$?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ DD imagerel ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ
	DD	imagerel ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z DD imagerel ?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z
	DD	imagerel ?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z+50
	DD	imagerel $unwind$?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z DD imagerel ??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z
	DD	imagerel ??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z+208
	DD	imagerel $unwind$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z DD imagerel ??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z
	DD	imagerel ??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z+84
	DD	imagerel $unwind$??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+79
	DD	imagerel $unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD imagerel ??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
	DD	imagerel ??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z+93
	DD	imagerel $unwind$??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z DD imagerel ??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z
	DD	imagerel ??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z+48
	DD	imagerel $unwind$??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+53
	DD	imagerel $unwind$??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+109
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD imagerel ??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
	DD	imagerel ??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z+77
	DD	imagerel $unwind$??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z+73
	DD	imagerel $unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@EELNAHHD@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@
CONST	SEGMENT
??_C@_1EA@EELNAHHD@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@ DB '"'
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'e', 00H
	DB	'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PEOHNLIM@front?$CI?$CJ?5called?5on?5empty?5deque@
CONST	SEGMENT
??_C@_0BO@PEOHNLIM@front?$CI?$CJ?5called?5on?5empty?5deque@ DB 'front() c'
	DB	'alled on empty deque', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
CONST	SEGMENT
??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@ DB '"'
	DB	00H, 'd', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H
	DB	'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'b'
	DB	00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'p', 00H, 'o', 00H, 'p', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '8', 00H, '.', 00H, '3', 00H, '3', 00H, '1'
	DB	00H, '3', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H, 'e'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\deque', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
CONST	SEGMENT
??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@ DB 'deque empty before pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@OMEADHM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MG@OMEADHM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '8', 00H, '.', 00H, '3', 00H, '3', 00H, '1'
	DB	00H, '3', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u'
	DB	00H, 't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@OFOHMBDA@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GD@OFOHMBDA@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\xutility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@OOHEPMDG@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@OOHEPMDG@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\xlocnum', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Maklocwcs@std@@YAPEA_WPEB_W@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Maklocwcs@std@@YAPEA_WPEB_W@Z@4JA DD 047H ; `std::_Maklocwcs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GC@GNDJPOJH@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@GNDJPOJH@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\xlocale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '8', 00H, '.', 00H, '3', 00H, '3', 00H, '1'
	DB	00H, '3', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051c01H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 060H
	DD	imagerel $ip2state$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051819H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0b7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z DB 060H
	DD	imagerel $ip2state$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z DD 025053d19H
	DD	010e2313H
	DD	070070029H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z
	DD	013bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcName$0 DB 05fH ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>
	DB	046H
	DB	06eH
	DB	056H
	DB	061H
	DB	06cH
	DB	073H
	DB	00H
	ORG $+8
??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcVarDesc DD 028H ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>
	DD	08H
	DQ	FLAT:??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcName$0
	ORG $+48
??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcFrameData DD 01H ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>
	DD	00H
	DQ	FLAT:??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z DD 05051601H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 06H
	DB	00H
	DB	00H
	DB	0daH
	DB	02H
	DB	019H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel $ip2state$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 035054219H
	DD	01133318H
	DD	0700c0029H
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	0132H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcName$0 DB 05fH ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DB	044H
	DB	065H
	DB	063H
	DB	061H
	DB	079H
	DB	05fH
	DB	063H
	DB	06fH
	DB	070H
	DB	069H
	DB	065H
	DB	064H
	DB	00H
	ORG $+2
??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcVarDesc DD 038H ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DD	08H
	DQ	FLAT:??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcName$0
	ORG $+48
??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcFrameData DD 01H ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DD	00H
	DQ	FLAT:??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z DD 025051d01H
	DD	0118231dH
	DD	070110039H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z DD 035051801H
	DD	01133318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z DD 05051601H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	040H
	DB	0f8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z DB 06H
	DB	00H
	DB	00H
	DB	'1', 02H
	DB	02H
	DB	08cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z DD 025054719H
	DD	0118231dH
	DD	070110027H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z
	DD	012aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcName$0 DB 05fH ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DB	042H
	DB	061H
	DB	063H
	DB	06bH
	DB	06fH
	DB	075H
	DB	074H
	DB	00H
	ORG $+7
??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcVarDesc DD 028H ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DD	010H
	DQ	FLAT:??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcName$0
	ORG $+48
??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcFrameData DD 01H ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DD	00H
	DQ	FLAT:??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 035051301H
	DD	010e3313H
	DD	07007002bH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0fbH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	'y', 02H
	DB	02H
	DB	'n'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DD 025054c19H
	DD	011d2322H
	DD	07016002fH
	DD	05015H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
	DD	016aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcName$0 DB 05fH ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
	DB	042H
	DB	061H
	DB	063H
	DB	06bH
	DB	06fH
	DB	075H
	DB	074H
	DB	00H
	ORG $+7
??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcVarDesc DD 068H ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
	DD	018H
	DQ	FLAT:??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcName$0
	ORG $+48
??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcFrameData DD 01H ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
	DD	00H
	DQ	FLAT:??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	040H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z DD 025054719H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0158H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcName$0 DB 05fH ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DB	055H
	DB	046H
	DB	069H
	DB	072H
	DB	073H
	DB	074H
	DB	00H
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcName$1 DB 05fH ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DB	055H
	DB	04cH
	DB	061H
	DB	073H
	DB	074H
	DB	00H
	ORG $+1
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcVarDesc DD 048H ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DD	08H
	DQ	FLAT:??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcName$0
	ORG $+96
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcFrameData DD 02H ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	DD	00H
	DQ	FLAT:??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	026bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 06H
	DB	00H
	DB	00H
	DB	019H, 05H
	DB	02H
	DB	']', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025054719H
	DD	0118231dH
	DD	070110049H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
	DD	023bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcName$0 DB 05fH ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DB	04eH
	DB	065H
	DB	077H
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+3
??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcVarDesc DD 0108H ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DD	08H
	DQ	FLAT:??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcName$0
	ORG $+48
??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcFrameData DD 01H ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >
	DD	00H
	DQ	FLAT:??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c002bH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z DD 025051d19H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c0027H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?worker@thread_pool@@AEAAXXZ DB 010H
	DB	00H
	DB	00H
	DB	0bcH
	DB	02H
	DB	'L'
	DB	04H
	DB	0ccH
	DB	02H
	DB	014H
	DB	00H
	DB	016H
	DB	04H
	DB	'f'
	DB	02H
	DB	'&'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?worker@thread_pool@@AEAAXXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?worker@thread_pool@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?worker@thread_pool@@AEAAXXZ
	DD	imagerel $ip2state$?worker@thread_pool@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?worker@thread_pool@@AEAAXXZ DD 025053d19H
	DD	010e2313H
	DD	070070035H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?worker@thread_pool@@AEAAXXZ
	DD	0192H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?worker@thread_pool@@AEAAXXZ$rtcName$0 DB 074H		; thread_pool::worker
	DB	061H
	DB	073H
	DB	06bH
	DB	00H
	ORG $+3
?worker@thread_pool@@AEAAXXZ$rtcName$1 DB 06cH		; thread_pool::worker
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+3
?worker@thread_pool@@AEAAXXZ$rtcVarDesc DD 088H		; thread_pool::worker
	DD	010H
	DQ	FLAT:?worker@thread_pool@@AEAAXXZ$rtcName$1
	DD	030H
	DD	040H
	DQ	FLAT:?worker@thread_pool@@AEAAXXZ$rtcName$0
	ORG $+96
?worker@thread_pool@@AEAAXXZ$rtcFrameData DD 02H	; thread_pool::worker
	DD	00H
	DQ	FLAT:?worker@thread_pool@@AEAAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	0178H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z DD 025054219H
	DD	01132318H
	DD	0700c002fH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcName$0 DB 05fH ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcVarDesc DD 044H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off
	DD	04H
	DQ	FLAT:?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcName$0
	ORG $+48
?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcFrameData DD 01H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off
	DD	00H
	DQ	FLAT:?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01cfH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD 025053d19H
	DD	010e2313H
	DD	070070027H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
	DD	012bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcName$0 DB 05fH ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
	DB	041H
	DB	06cH
	DB	06dH
	DB	061H
	DB	070H
	DB	00H
	ORG $+9
?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcVarDesc DD 024H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
	DD	01H
	DQ	FLAT:?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcName$0
	ORG $+48
?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcFrameData DD 01H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
	DD	00H
	DQ	FLAT:?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	0427H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z DD 025054219H
	DD	01132318H
	DD	0700c0035H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0190H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcName$0 DB 05fH ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
	DB	041H
	DB	06cH
	DB	06dH
	DB	061H
	DB	070H
	DB	00H
	ORG $+1
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcName$1 DB 05fH ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
	DB	04eH
	DB	065H
	DB	077H
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+15
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcVarDesc DD 048H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
	DD	08H
	DQ	FLAT:?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcName$1
	DD	024H
	DD	01H
	DQ	FLAT:?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcName$0
	ORG $+96
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcFrameData DD 02H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
	DD	00H
	DQ	FLAT:?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD 035051319H
	DD	010e3313H
	DD	070070029H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD 035051319H
	DD	010e3313H
	DD	070070025H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ DD 035051301H
	DD	010e3313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0afH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcName$0 DB 05fH ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	DB	050H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	05fH
	DB	061H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	074H
	DB	06fH
	DB	072H
	DB	00H
	ORG $+15
??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcVarDesc DD 024H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	DD	01H
	DQ	FLAT:??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	DD	00H
	DQ	FLAT:??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	070070027H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$function@$$A6AXXZ@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'b'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DD 025051811H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$function@$$A6AXXZ@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Func_class@X$$V@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@X$$V@std@@QEBAXXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Func_class@X$$V@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	040H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DB 06H
	DB	00H
	DB	00H
	DB	0c6H
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
	DD	imagerel $ip2state$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD 025054719H
	DD	0118231dH
	DD	070110021H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
	DD	0faH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcName$0 DB 05fH ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcVarDesc DD 024H ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
	DD	04H
	DQ	FLAT:?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcName$0
	ORG $+48
?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcFrameData DD 01H ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
	DD	00H
	DQ	FLAT:?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z DD 025051d01H
	DD	0118231dH
	DD	070110029H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ DD 025051319H
	DD	010e2313H
	DD	070070031H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z DD 025052201H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0b2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070029H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcName$0 DB 024H ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
	DB	053H
	DB	038H
	DB	00H
	ORG $+12
??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcVarDesc DD 044H ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
	DD	01H
	DQ	FLAT:??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
	DD	00H
	DQ	FLAT:??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ DD 025051319H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@Vthread@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	0d5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	084H
	DB	02H
	DB	'd'
	DB	04H
	DB	'L'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z
	DD	imagerel $ip2state$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z DD 025054219H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z
	DD	0112H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcName$0 DB 06cH ; thread_pool::enqueue
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+11
?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcVarDesc DD 028H ; thread_pool::enqueue
	DD	010H
	DQ	FLAT:?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcName$0
	ORG $+48
?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcFrameData DD 01H ; thread_pool::enqueue
	DD	00H
	DQ	FLAT:?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	015eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1thread_pool@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1thread_pool@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1thread_pool@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1thread_pool@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070033H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??1thread_pool@@QEAA@XZ
	DD	018bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1thread_pool@@QEAA@XZ$rtcName$0 DB 06cH		; thread_pool::~thread_pool
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+11
??1thread_pool@@QEAA@XZ$rtcVarDesc DD 028H		; thread_pool::~thread_pool
	DD	010H
	DQ	FLAT:??1thread_pool@@QEAA@XZ$rtcName$0
	ORG $+48
??1thread_pool@@QEAA@XZ$rtcFrameData DD 01H		; thread_pool::~thread_pool
	DD	00H
	DQ	FLAT:??1thread_pool@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0thread_pool@@QEAA@_K@Z DB 0cH
	DB	00H
	DB	00H
	DB	'h'
	DB	02H
	DB	'('
	DB	04H
	DB	'('
	DB	06H
	DB	','
	DB	08H
	DB	0c4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0thread_pool@@QEAA@_K@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0thread_pool@@QEAA@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??0thread_pool@@QEAA@_K@Z
	DD	imagerel $ip2state$??0thread_pool@@QEAA@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0thread_pool@@QEAA@_K@Z DD 025051811H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0thread_pool@@QEAA@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z DD 05051601H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?notify_all@condition_variable@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?notify_one@condition_variable@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1condition_variable@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0condition_variable@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1mutex@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0mutex@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@_Mutex_base@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@_Mutex_base@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Mutex_base@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Mutex_base@std@@QEAA@H@Z DD 025051701H
	DD	01122317H
	DD	0700b001fH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z DD 025063701H
	DD	0119231eH
	DD	070120022H
	DD	050106011H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcName$0 DB 05fH ; std::exchange<_Thrd_t,_Thrd_t>
	DB	04fH
	DB	06cH
	DB	064H
	DB	05fH
	DB	076H
	DB	061H
	DB	06cH
	DB	00H
	ORG $+7
??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcVarDesc DD 028H ; std::exchange<_Thrd_t,_Thrd_t>
	DD	010H
	DQ	FLAT:??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcName$0
	ORG $+48
??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcFrameData DD 01H ; std::exchange<_Thrd_t,_Thrd_t>
	DD	00H
	DQ	FLAT:??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gthread@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?join@thread@std@@QEAAXXZ DD 025061401H
	DD	010f2314H
	DD	070080028H
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?joinable@thread@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0thread@std@@QEAA@$$QEAV01@@Z DD 025061901H
	DD	01142319H
	DD	0700d0028H
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1thread@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD 025061e01H
	DD	0119231eH
	DD	070120026H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD 025061e01H
	DD	0119231eH
	DD	070120026H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD 035051d01H
	DD	0118331dH
	DD	07011002bH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Maklocwcs@std@@YAPEA_WPEB_W@Z DD 035051301H
	DD	010e3313H
	DD	070070027H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	0231H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z DD 035054719H
	DD	0118331dH
	DD	070110047H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0228H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$0 DB 05fH ; std::_Maklocstr<wchar_t>
	DB	057H
	DB	063H
	DB	00H
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$1 DB 05fH ; std::_Maklocstr<wchar_t>
	DB	04dH
	DB	062H
	DB	073H
	DB	074H
	DB	031H
	DB	00H
	ORG $+1
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$2 DB 05fH ; std::_Maklocstr<wchar_t>
	DB	04dH
	DB	062H
	DB	073H
	DB	074H
	DB	032H
	DB	00H
	ORG $+13
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcVarDesc DD 0158H ; std::_Maklocstr<wchar_t>
	DD	08H
	DQ	FLAT:??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$2
	DD	0f8H
	DD	08H
	DQ	FLAT:??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$1
	DD	0d4H
	DD	02H
	DQ	FLAT:??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcName$0
	ORG $+144
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcFrameData DD 03H ; std::_Maklocstr<wchar_t>
	DD	00H
	DQ	FLAT:??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	07eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025053d19H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0 DB 05fH ; std::_Container_base12::_Orphan_all_locked_v3
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc DD 024H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	04H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0
	ORG $+48
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData DD 01H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	00H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_base12@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035051801H
	DD	01133318H
	DD	0700c002fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max@?$numeric_limits@_J@std@@SA_JXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcpy DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	070030023H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KPEAX@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\tuple
;	COMDAT ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
this$ = 224
_Arg$ = 232
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> >::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__19EA4BD2_tuple
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR _Arg$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> >::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
<_Val2_0>$ = 240
??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1><std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > * &>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR <_Val2_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1><std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
$T1 = 196
tv75 = 216
this$ = 256
__formal$ = 264
_This_arg$ = 272
??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><std::_Exact_args_t,`thread_pool::thread_pool'::`4'::<lambda_1>,0>, COMDAT

; 315  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__19EA4BD2_tuple
	call	__CheckForDebuggerJustMyCode
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv75[rbp], rax
	mov	rdx, QWORD PTR _This_arg$[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	call	??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Tuple_val@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> >::_Tuple_val<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1> >
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><std::_Exact_args_t,`thread_pool::thread_pool'::`4'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::invoke<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 1730 :     -> decltype(static_cast<_Callable&&>(_Obj)()) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1731 :     return static_cast<_Callable&&>(_Obj)();

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ ; `thread_pool::thread_pool'::`4'::<lambda_1>::operator()

; 1732 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::invoke<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\tuple
;	COMDAT ??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 224
??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z PROC ; std::get<0,`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 942  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__19EA4BD2_tuple
	call	__CheckForDebuggerJustMyCode

; 943  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 944  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

	mov	rax, QWORD PTR _Tuple$[rbp]

; 945  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z ENDP ; std::get<0,`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
_TEXT	SEGMENT
$T1 = 196
tv70 = 216
this$ = 256
_Ptr$ = 264
??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z PROC ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > ><std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,0>, COMDAT

; 3223 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv70[rbp], rax
	lea	r8, QWORD PTR _Ptr$[rbp]
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv70[rbp]
	call	??$?0AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1><std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > * &>
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ENDP ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > ><std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\tuple
;	COMDAT ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
$T1 = 196
this$ = 256
_This_arg$ = 264
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1>,0>, COMDAT

; 361  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__19EA4BD2_tuple
	call	__CheckForDebuggerJustMyCode
	mov	r8, QWORD PTR _This_arg$[rbp]
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$?0U_Exact_args_t@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@U_Exact_args_t@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><std::_Exact_args_t,`thread_pool::thread_pool'::`4'::<lambda_1>,0>
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__394B8783_utility
	call	__CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR _New_val$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 764  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rbp]

; 765  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z
_TEXT	SEGMENT
_FnVals$ = 8
_Tup$ = 40
$T4 = 260
__$ArrayPad$ = 280
_RawVals$ = 320
??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z PROC ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>, COMDAT

; 56   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 26
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 57   :         // adapt invoke of user's callable object to _beginthreadex's thread procedure
; 58   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

	mov	edx, 8
	lea	rcx, QWORD PTR _FnVals$[rbp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z
	mov	rdx, QWORD PTR _RawVals$[rbp]
	lea	rcx, QWORD PTR _FnVals$[rbp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > ><std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,0>

; 59   :         _Tuple& _Tup = *_FnVals.get(); // avoid ADL, handle incomplete types

	lea	rcx, QWORD PTR _FnVals$[rbp]
	call	?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::get
	mov	QWORD PTR _Tup$[rbp], rax

; 60   :         _STD invoke(_STD move(_STD get<_Indices>(_Tup))...);

	mov	rcx, QWORD PTR _Tup$[rbp]
	call	??$get@$0A@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAAEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@AEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@@Z ; std::get<0,`thread_pool::thread_pool'::`4'::<lambda_1> >
	mov	rcx, rax
	call	??$invoke@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@YAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::invoke<`thread_pool::thread_pool'::`4'::<lambda_1> >

; 61   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	_Cnd_do_broadcast_at_thread_exit

; 62   :         return 0;

	mov	DWORD PTR $T4[rbp], 0
	lea	rcx, QWORD PTR _FnVals$[rbp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::~unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >
	mov	eax, DWORD PTR $T4[rbp]

; 63   :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z ENDP ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 224
classSize$ = 232
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z PROC ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::__autoclassinit2, COMDAT
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rbp, rsp
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR classSize$[rbp]
	rep stosb
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1527 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1528 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
_TEXT	SEGMENT
$T1 = 196
this$ = 256
?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ PROC ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::release, COMDAT

; 3308 :     _CONSTEXPR23 pointer release() noexcept {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode

; 3309 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	QWORD PTR $T1[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, rax
	call	??$exchange@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$$T@std@@YAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,std::nullptr_t>

; 3310 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ ENDP ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ
_TEXT	SEGMENT
this$ = 224
?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ PROC ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::get, COMDAT

; 3300 :     _NODISCARD _CONSTEXPR23 pointer get() const noexcept {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode

; 3301 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]

; 3302 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ ENDP ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 192
tv75 = 200
this$ = 240
??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::~unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >, COMDAT

; 3278 :     _CONSTEXPR23 ~unique_ptr() noexcept {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode

; 3279 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3280 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > *,1>::_Get_first
	mov	QWORD PTR tv77[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rbp], rax
	mov	rdx, QWORD PTR tv75[rbp]
	mov	rcx, QWORD PTR tv77[rbp]
	call	??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ; std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >::operator()
$LN2@unique_ptr:

; 3281 :         }
; 3282 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::~unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z
_TEXT	SEGMENT
$T1 = 200
tv67 = 216
this$ = 256
_Ptr$ = 264
??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z PROC ; std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >::operator(), COMDAT

; 3168 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode

; 3169 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3170 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR $T1[rbp], rax
	mov	edx, 8
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	cmp	QWORD PTR $T1[rbp], 0
	jne	SHORT $LN3@operator
	mov	QWORD PTR tv67[rbp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR _Ptr$[rbp], 33059		; 00008123H
	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR tv67[rbp], rax
$LN4@operator:

; 3171 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??R?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@QEBAXPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ENDP ; std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\memory
;	COMDAT ??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
$T1 = 200
$T2 = 228
tv75 = 248
__$ReturnUdt$ = 288
<_Args_0>$ = 296
??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::make_unique<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,`thread_pool::thread_pool'::`4'::<lambda_1>,0>, COMDAT

; 3464 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	DWORD PTR $T2[rbp], 0
	lea	rcx, OFFSET FLAT:__A092E177_memory
	call	__CheckForDebuggerJustMyCode

; 3465 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rbp], rax
	cmp	QWORD PTR $T1[rbp], 0
	je	SHORT $LN3@make_uniqu
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> ><`thread_pool::thread_pool'::`4'::<lambda_1>,0>
	mov	QWORD PTR tv75[rbp], rax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	QWORD PTR tv75[rbp], 0
$LN4@make_uniqu:
	mov	rdx, QWORD PTR tv75[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@PEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@1@@Z ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > ><std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > >,0>
	mov	eax, DWORD PTR $T2[rbp]
	or	eax, 1
	mov	DWORD PTR $T2[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 3466 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::make_unique<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,`thread_pool::thread_pool'::`4'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z PROC ; std::construct_at<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR $T1[rbp]

; 243  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z ENDP ; std::construct_at<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z PROC ; std::addressof<std::function<void __cdecl(void)> *>, COMDAT

; 1585 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1586 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1587 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z ENDP ; std::addressof<std::function<void __cdecl(void)> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::thread,std::thread,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0thread@std@@QEAA@$$QEAV01@@Z		; std::thread::thread

; 243  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::thread,std::thread,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_Decay_copied$ = 8
_Invoker_proc$ = 40
tv74 = 248
__$ArrayPad$ = 256
this$ = 304
_Fx$ = 312
??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 73   :     void _Start(_Fn&& _Fx, _Args&&... _Ax) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 22
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 74   :         using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
; 75   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

	mov	edx, 8
	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAX_K@Z
	mov	rdx, QWORD PTR _Fx$[rbp]
	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	??$make_unique@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@0@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::make_unique<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,`thread_pool::thread_pool'::`4'::<lambda_1>,0>
	npad	1

; 76   :         constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

	lea	rax, OFFSET FLAT:??$_Invoke@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@$0A@@thread@std@@CAIPEAX@Z ; std::thread::_Invoke<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,0>
	mov	QWORD PTR _Invoker_proc$[rbp], rax

; 77   : 
; 78   :         _Thr._Hnd =

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	QWORD PTR tv74[rbp], rax
	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	?get@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEBAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::get
	mov	rcx, QWORD PTR tv74[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, rax
	mov	r8, QWORD PTR _Invoker_proc$[rbp]
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__beginthreadex
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx], rax

; 79   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 80   : 
; 81   :         if (_Thr._Hnd) { // ownership transferred to the thread

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Start

; 82   :             (void) _Decay_copied.release();

	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	?release@?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAAPEAV?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@2@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::release

; 83   :         } else { // failed to start thread

	jmp	SHORT $LN3@Start
$LN2@Start:

; 84   :             _Thr._Id = 0;

	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+8], 0

; 85   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	npad	1
$LN3@Start:

; 86   :         }
; 87   :     }

	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::~unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
$LN6@Start:
??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Decay_copied$ = 8
_Invoker_proc$ = 40
tv74 = 248
__$ArrayPad$ = 256
this$ = 304
_Fx$ = 312
?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA PROC ; `std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+48]
	lea	rcx, QWORD PTR _Decay_copied$[rbp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@U?$default_delete@V?$tuple@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >::~unique_ptr<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> >,std::default_delete<std::tuple<`thread_pool::thread_pool'::`4'::<lambda_1> > > >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA ENDP ; `std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z
_TEXT	SEGMENT
$T1 = 200
_Obj$ = 256
<_Args_0>$ = 264
??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z PROC ; std::_Construct_in_place<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> *>
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, rax
	call	??$construct_at@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@$0A@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@AEAPEAV10@@Z ; std::construct_at<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &,0>

; 252  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAPEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z ENDP ; std::_Construct_in_place<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
<_Args_0>$ = 240
??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,std::thread>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$construct_at@Vthread@std@@V12@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::thread,std::thread,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 247  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__19EA4BD2_tuple
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z PROC ; std::to_address<std::function<void __cdecl(void)> *>, COMDAT

; 328  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 329  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 330  :     return _Val;

	mov	rax, QWORD PTR _Val$[rbp]

; 331  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ENDP ; std::to_address<std::function<void __cdecl(void)> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
_Val$ = 224
??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z PROC ; std::_To_address<std::function<void __cdecl(void)> * *>, COMDAT

; 4381 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 4382 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4383 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$to_address@PEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ; std::to_address<std::function<void __cdecl(void)> *>

; 4384 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ENDP ; std::_To_address<std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
this$ = 224
<_Vals_0>$ = 232
??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Emplace_back<std::function<void __cdecl(void)> * &>, COMDAT

; 1618 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1619 :         // construct a new element at *_Last and increment
; 1620 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rdx, QWORD PTR <_Vals_0>$[rbp]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Construct_in_place@PEAV?$function@$$A6AXXZ@std@@AEAPEAV12@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Construct_in_place<std::function<void __cdecl(void)> *,std::function<void __cdecl(void)> * &>

; 1621 :         ++_Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 1622 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Emplace_back<std::function<void __cdecl(void)> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ PROC ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Release, COMDAT

; 1624 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1625 :         _First = _Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1626 :         return _Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]

; 1627 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::~_Uninitialized_backout<std::function<void __cdecl(void)> * *>, COMDAT

; 1613 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1614 :         _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ; std::_Destroy_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>

; 1615 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::~_Uninitialized_backout<std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
this$ = 224
_Dest$ = 232
??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Uninitialized_backout<std::function<void __cdecl(void)> * *>, COMDAT

; 1606 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Dest$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Dest$[rbp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Uninitialized_backout<std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z
_TEXT	SEGMENT
_FirstPtr$ = 8
_LastPtr$ = 40
_DestPtr$ = 72
_First_ch$ = 104
_Last_ch$ = 136
_Dest_ch$ = 168
_Count$ = 200
_First$ = 448
_Last$ = 456
_Dest$ = 464
??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z PROC ; std::_Copy_memmove<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 4513 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 456				; 000001c8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 4514 :     auto _FirstPtr              = _To_address(_First);

	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _FirstPtr$[rbp], rax

; 4515 :     auto _LastPtr               = _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rbp]
	call	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _LastPtr$[rbp], rax

; 4516 :     auto _DestPtr               = _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rbp]
	call	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _DestPtr$[rbp], rax

; 4517 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rax, QWORD PTR _FirstPtr$[rbp]
	mov	QWORD PTR _First_ch$[rbp], rax

; 4518 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	rax, QWORD PTR _LastPtr$[rbp]
	mov	QWORD PTR _Last_ch$[rbp], rax

; 4519 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	rax, QWORD PTR _DestPtr$[rbp]
	mov	QWORD PTR _Dest_ch$[rbp], rax

; 4520 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rbp]
	mov	rcx, QWORD PTR _Last_ch$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rbp], rax

; 4521 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _First_ch$[rbp]
	mov	rcx, QWORD PTR _Dest_ch$[rbp]
	call	memmove

; 4522 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4523 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Dest_ch$[rbp]
	add	rcx, rax
	mov	rax, rcx

; 4524 :     } else {
; 4525 :         return _Dest + (_LastPtr - _FirstPtr);
; 4526 :     }
; 4527 : }

	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z ENDP ; std::_Copy_memmove<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z PROC ; std::_Verify_range<std::function<void __cdecl(void)> *>, COMDAT

; 1130 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 1131 :     // special case range verification for pointers
; 1132 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	rax, QWORD PTR _Last$[rbp]
	cmp	QWORD PTR _First$[rbp], rax
	ja	SHORT $LN7@Verify_ran
	jmp	SHORT $LN9@Verify_ran
$LN7@Verify_ran:
	lea	rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1132				; 0000046cH
	lea	rdx, OFFSET FLAT:??_C@_0GD@OFOHMBDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN11@Verify_ran
	int	3
	xor	eax, eax
$LN11@Verify_ran:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1132				; 0000046cH
	lea	r8, OFFSET FLAT:??_C@_1MG@OMEADHM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Verify_ran
$LN9@Verify_ran:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@Verify_ran

; 1133 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z ENDP ; std::_Verify_range<std::function<void __cdecl(void)> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z
_TEXT	SEGMENT
tv74 = 192
tv72 = 200
this$ = 240
<_Vals_0>$ = 248
??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Emplace_back<std::thread>, COMDAT

; 1800 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1801 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ; std::_Unfancy<std::thread>
	mov	QWORD PTR tv74[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv72[rbp], rax
	mov	r8, QWORD PTR <_Vals_0>$[rbp]
	mov	rdx, QWORD PTR tv74[rbp]
	mov	rcx, QWORD PTR tv72[rbp]
	call	??$construct@Vthread@std@@V12@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,std::thread>

; 1802 :         ++_Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 1803 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Emplace_back<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 224
classSize$ = 232
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::__autoclassinit2, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rbp, rsp
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR classSize$[rbp]
	rep stosb
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Release, COMDAT

; 1805 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1806 :         _First = _Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1807 :         return _Last;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]

; 1808 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::~_Uninitialized_backout_al<std::allocator<std::thread> >, COMDAT

; 1795 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1796 :         _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rbp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread> >

; 1797 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::~_Uninitialized_backout_al<std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
_Dest$ = 232
_Al_$ = 240
??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Uninitialized_backout_al<std::allocator<std::thread> >, COMDAT

; 1790 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Dest$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Dest$[rbp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Al_$[rbp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Uninitialized_backout_al<std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z
_TEXT	SEGMENT
_It$ = 224
??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z PROC ; std::_Get_unwrapped<std::thread * const &>, COMDAT

; 1175 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1176 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1177 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1178 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rbp]
	mov	rax, QWORD PTR [rax]

; 1179 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1180 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1181 :     } else {
; 1182 :         return static_cast<_Iter&&>(_It);
; 1183 :     }
; 1184 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z ENDP ; std::_Get_unwrapped<std::thread * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::construct_at<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1>,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::thread::thread<`thread_pool::thread_pool'::`4'::<lambda_1>,0>

; 243  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::construct_at<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 4
_Max_possible$1 = 40
_Count$ = 288
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rbp]
	shl	rax, 3
$LN3@Get_size_o:

; 75   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z
_TEXT	SEGMENT
_First_ch$ = 8
_Last_ch$ = 40
_First$ = 288
_Last$ = 296
??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z PROC ; std::_Zero_range<std::function<void __cdecl(void)> * *>, COMDAT

; 2016 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 2017 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));

	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _First_ch$[rbp], rax

; 2018 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));

	lea	rcx, QWORD PTR _Last$[rbp]
	call	??$_To_address@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_To_address<std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _Last_ch$[rbp], rax

; 2019 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rax, QWORD PTR _First_ch$[rbp]
	mov	rcx, QWORD PTR _Last_ch$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR _First_ch$[rbp]
	call	memset

; 2020 :     return _Last;

	mov	rax, QWORD PTR _Last$[rbp]

; 2021 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z ENDP ; std::_Zero_range<std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z
_TEXT	SEGMENT
_It$ = 224
_UIt$ = 232
??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z PROC ; std::_Seek_wrapped<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1275 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1276 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1277 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1278 :     } else {
; 1279 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR _It$[rbp]
	mov	rcx, QWORD PTR _UIt$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1280 :     }
; 1281 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z ENDP ; std::_Seek_wrapped<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z
_TEXT	SEGMENT
_Backout$ = 8
$T4 = 248
__$ArrayPad$ = 264
_First$ = 304
_Last$ = 312
_Dest$ = 320
??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z PROC ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1894 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 22
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+344]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1895 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1896 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1897 : #if _HAS_CXX20
; 1898 :         if (!_STD is_constant_evaluated())

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Uninitiali

; 1899 : #endif // _HAS_CXX20
; 1900 :         {
; 1901 :             return _Copy_memmove(_First, _Last, _Dest);

	mov	r8, QWORD PTR _Dest$[rbp]
	mov	rdx, QWORD PTR _Last$[rbp]
	mov	rcx, QWORD PTR _First$[rbp]
	call	??$_Copy_memmove@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@00@Z ; std::_Copy_memmove<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	jmp	SHORT $LN1@Uninitiali
$LN5@Uninitiali:

; 1902 :         }
; 1903 :     }
; 1904 : 
; 1905 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};

	mov	rdx, QWORD PTR _Dest$[rbp]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??0?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@PEAPEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Uninitialized_backout<std::function<void __cdecl(void)> * *>
	npad	1

; 1906 :     for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _First$[rbp]
	add	rax, 8
	mov	QWORD PTR _First$[rbp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _Last$[rbp]
	cmp	QWORD PTR _First$[rbp], rax
	je	SHORT $LN3@Uninitiali

; 1907 :         _Backout._Emplace_back(*_First);

	mov	rdx, QWORD PTR _First$[rbp]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??$_Emplace_back@AEAPEAV?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAXAEAPEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Emplace_back<std::function<void __cdecl(void)> * &>

; 1908 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1909 : 
; 1910 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rbp]
	call	?_Release@?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::_Release
	mov	QWORD PTR $T4[rbp], rax
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::~_Uninitialized_backout<std::function<void __cdecl(void)> * *>
	mov	rax, QWORD PTR $T4[rbp]
$LN1@Uninitiali:

; 1911 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z ENDP ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 8
$T4 = 248
__$ArrayPad$ = 264
_First$ = 304
_Last$ = 312
_Dest$ = 320
?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA PROC ; `std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout@PEAPEAV?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::function<void __cdecl(void)> * *>::~_Uninitialized_backout<std::function<void __cdecl(void)> * *>
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z@4HA ENDP ; `std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z
_TEXT	SEGMENT
_It$ = 224
_Off$ = 232
??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z PROC ; std::_Get_unwrapped_n<std::function<void __cdecl(void)> * * &,__int64>, COMDAT

; 1241 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1242 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1243 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rbp]
	mov	rax, QWORD PTR [rax]

; 1244 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1245 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1246 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1247 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1248 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1249 : 
; 1250 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1251 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1252 :             "integer overflow");
; 1253 :         (void) _COff;
; 1254 : 
; 1255 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1256 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1257 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1258 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1259 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1260 :     } else {
; 1261 :         // pass through iterator that doesn't participate in checking
; 1262 :         return static_cast<_Iter&&>(_It);
; 1263 :     }
; 1264 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::function<void __cdecl(void)> * * &,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z PROC ; std::_Idl_distance<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1336 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1337 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1338 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1339 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR _Last$[rbp]
	mov	rcx, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 3

; 1340 :     } else {
; 1341 :         return _Distance_unknown{};
; 1342 :     }
; 1343 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ENDP ; std::_Idl_distance<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
_It$ = 224
??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z PROC ; std::_Get_unwrapped<std::function<void __cdecl(void)> * * const &>, COMDAT

; 1175 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1176 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1177 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1178 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rbp]
	mov	rax, QWORD PTR [rax]

; 1179 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1180 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1181 :     } else {
; 1182 :         return static_cast<_Iter&&>(_It);
; 1183 :     }
; 1184 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ENDP ; std::_Get_unwrapped<std::function<void __cdecl(void)> * * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z PROC ; std::_Adl_verify_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1152 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 1153 :     // check that [_First, _Last) forms an iterator range
; 1154 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1155 :         _Verify_range(_First, _Last);

	mov	rax, QWORD PTR _Last$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Verify_range@PEAV?$function@$$A6AXXZ@std@@@std@@YAXQEBQEAV?$function@$$A6AXXZ@0@0@Z ; std::_Verify_range<std::function<void __cdecl(void)> *>

; 1156 :     }
; 1157 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ENDP ; std::_Adl_verify_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Block_size$ = 8
_Ptr_container$ = 40
_Ptr$ = 72
_Bytes$ = 320
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 136  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 137  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 138  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rbp]
	add	rax, 47					; 0000002fH
	mov	QWORD PTR _Block_size$[rbp], rax

; 139  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rbp]
	cmp	QWORD PTR _Block_size$[rbp], rax
	ja	SHORT $LN8@Allocate_m

; 140  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 141  :     }
; 142  : 
; 143  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rbp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rbp], rax
$LN4@Allocate_m:

; 144  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rbp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	lea	rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 144				; 00000090H
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
	xor	eax, eax
$LN12@Allocate_m:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 144				; 00000090H
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 145  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rbp]
	add	rax, 47					; 0000002fH
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rbp], rax

; 146  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rbp]
	mov	rdx, QWORD PTR _Ptr_container$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 147  : 
; 148  : #ifdef _DEBUG
; 149  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr$[rbp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	mov	QWORD PTR [rcx+rax], rdx

; 150  : #endif // defined(_DEBUG)
; 151  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]
$LN11@Allocate_m:

; 152  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z
_TEXT	SEGMENT
_Location$ = 224
??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z PROC ; std::destroy_at<std::thread>, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Location$[rbp]
	call	??_Gthread@std@@QEAAPEAXI@Z

; 321  :     }
; 322  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z ENDP ; std::destroy_at<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 64					; 00000040H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)>

; 243  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate

; 710  :         } else

	jmp	SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 8
_ULast$ = 40
_Backout$ = 72
$T4 = 312
__$ArrayPad$ = 328
_First$ = 368
_Last$ = 376
_Dest$ = 384
_Al$ = 392
??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z PROC ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >, COMDAT

; 1926 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1927 :     // move [_First, _Last) to raw _Dest, using _Al
; 1928 :     // note: only called internally from elsewhere in the STL
; 1929 :     using _Ptrval     = typename _Alloc::value_type*;
; 1930 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z ; std::_Get_unwrapped<std::thread * const &>
	mov	QWORD PTR _UFirst$[rbp], rax

; 1931 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rbp]
	call	??$_Get_unwrapped@AEBQEAVthread@std@@@std@@YA?A_TAEBQEAVthread@0@@Z ; std::_Get_unwrapped<std::thread * const &>
	mov	QWORD PTR _ULast$[rbp], rax

; 1932 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1933 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1934 : #if _HAS_CXX20
; 1935 :         if (!_STD is_constant_evaluated())
; 1936 : #endif // _HAS_CXX20
; 1937 :         {
; 1938 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1939 :             return _Dest + (_ULast - _UFirst);
; 1940 :         }
; 1941 :     }
; 1942 : 
; 1943 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	edx, 24
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX_K@Z
	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@PEAVthread@1@AEAV?$allocator@Vthread@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Uninitialized_backout_al<std::allocator<std::thread> >
	npad	1

; 1944 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rbp]
	add	rax, 16
	mov	QWORD PTR _UFirst$[rbp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rbp]
	cmp	QWORD PTR _UFirst$[rbp], rax
	je	SHORT $LN3@Uninitiali

; 1945 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rdx, QWORD PTR _UFirst$[rbp]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??$_Emplace_back@Vthread@std@@@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAX$$QEAVthread@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Emplace_back<std::thread>

; 1946 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1947 : 
; 1948 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rbp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAAPEAVthread@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::_Release
	mov	QWORD PTR $T4[rbp], rax
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::~_Uninitialized_backout_al<std::allocator<std::thread> >
	mov	rax, QWORD PTR $T4[rbp]

; 1949 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+344]
	pop	rdi
	pop	rbp
	ret	0
??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 8
_ULast$ = 40
_Backout$ = 72
$T4 = 312
__$ArrayPad$ = 328
_First$ = 368
_Last$ = 376
_Dest$ = 384
_Al$ = 392
?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@Vthread@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::thread> >::~_Uninitialized_backout_al<std::allocator<std::thread> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Count$ = 232
??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::thread> >, COMDAT

; 2198 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 2199 : #if _HAS_CXX23
; 2200 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2201 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2202 :         _Count                  = _Allocated;
; 2203 :         return _Ptr;
; 2204 :     } else
; 2205 : #endif // _HAS_CXX23
; 2206 :     {
; 2207 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z ; std::allocator<std::thread>::allocate

; 2208 :     }
; 2209 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
<_Args_0>$ = 240
??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$construct_at@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$0A@@std@@YAPEAVthread@0@QEAV10@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::construct_at<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1>,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
this$ = 224
_Fx$ = 232
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::thread::thread<`thread_pool::thread_pool'::`4'::<lambda_1>,0>, COMDAT

; 92   :     _NODISCARD_CTOR_THREAD explicit thread(_Fn&& _Fx, _Args&&... _Ax) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 93   :         _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

	mov	rdx, QWORD PTR _Fx$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Start@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V@thread@std@@AEAAX$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::thread::_Start<`thread_pool::thread_pool'::`4'::<lambda_1> >

; 94   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@$$V$0A@@thread@std@@QEAA@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::thread::thread<`thread_pool::thread_pool'::`4'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 4
_Max_possible$1 = 40
_Count$ = 288
??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<64>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rbp], 64		; 00000040H
$LN3@Get_size_o:

; 75   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z PROC ; std::_Destroy_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1097 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1098 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1099 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1100 :         for (; _First != _Last; ++_First) {
; 1101 :             _Destroy_in_place(*_First);
; 1102 :         }
; 1103 :     }
; 1104 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ENDP ; std::_Destroy_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z
_TEXT	SEGMENT
_UFirst$ = 224
_Count$ = 232
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>, COMDAT

; 2048 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 2049 :     // value-initialize all elements in [_UFirst, _UFirst + _Count)
; 2050 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 2051 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 2052 :         return _Zero_range(_UFirst, _UFirst + _Count);

	mov	rax, QWORD PTR _UFirst$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rdx, rax
	mov	rcx, QWORD PTR _UFirst$[rbp]
	call	??$_Zero_range@PEAPEAV?$function@$$A6AXXZ@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0@Z ; std::_Zero_range<std::function<void __cdecl(void)> * *>

; 2053 :     } else {
; 2054 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 2055 :         for (; 0 < _Count; --_Count) {
; 2056 :             _Backout._Emplace_back();
; 2057 :         }
; 2058 : 
; 2059 :         return _Backout._Release();
; 2060 :     }
; 2061 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z
_TEXT	SEGMENT
_UFirst$ = 8
_ULast$ = 40
_UDest$ = 72
$T5 = 296
__$ArrayPad$ = 312
_First$ = 352
_Last$ = 360
_Dest$ = 368
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z PROC ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>, COMDAT

; 1914 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1915 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1916 :     _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rbp]
	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_Adl_verify_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Adl_verify_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>

; 1917 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * * const &>
	mov	QWORD PTR _UFirst$[rbp], rax

; 1918 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rbp]
	call	??$_Get_unwrapped@AEBQEAPEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * * const &>
	mov	QWORD PTR _ULast$[rbp], rax

; 1919 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	rdx, QWORD PTR _ULast$[rbp]
	lea	rcx, QWORD PTR _UFirst$[rbp]
	call	??$_Idl_distance@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YA?A_PAEBQEAPEAV?$function@$$A6AXXZ@0@0@Z ; std::_Idl_distance<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Dest$[rbp]
	call	??$_Get_unwrapped_n@AEAPEAPEAV?$function@$$A6AXXZ@std@@_J@std@@YA?A_TAEAPEAPEAV?$function@$$A6AXXZ@0@_J@Z ; std::_Get_unwrapped_n<std::function<void __cdecl(void)> * * &,__int64>
	mov	QWORD PTR _UDest$[rbp], rax

; 1920 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));

	mov	r8, QWORD PTR _UDest$[rbp]
	mov	rdx, QWORD PTR _ULast$[rbp]
	mov	rcx, QWORD PTR _UFirst$[rbp]
	call	??$_Uninitialized_copy_unchecked@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@QEAPEAV10@0@Z ; std::_Uninitialized_copy_unchecked<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	mov	QWORD PTR $T5[rbp], rax
	lea	rdx, QWORD PTR $T5[rbp]
	lea	rcx, QWORD PTR _Dest$[rbp]
	call	??$_Seek_wrapped@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXAEAPEAPEAV?$function@$$A6AXXZ@0@$$QEAPEAPEAV10@@Z ; std::_Seek_wrapped<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>

; 1921 :     return _Dest;

	mov	rax, QWORD PTR _Dest$[rbp]

; 1922 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ENDP ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Count$ = 232
??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> *> >, COMDAT

; 2198 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 2199 : #if _HAS_CXX23
; 2200 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2201 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2202 :         _Count                  = _Allocated;
; 2203 :         return _Ptr;
; 2204 :     } else
; 2205 : #endif // _HAS_CXX23
; 2206 :     {
; 2207 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> *>::allocate

; 2208 :     }
; 2209 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 224
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Allocate

; 235  : #endif // _HAS_CXX20
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	QWORD PTR _Bytes$[rbp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	cmp	QWORD PTR _Bytes$[rbp], 0
	je	SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	jmp	SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	eax, eax
$LN1@Allocate:

; 248  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 4
_Max_possible$1 = 40
_Count$ = 288
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rbp], 16
$LN3@Get_size_o:

; 75   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::thread> >::destroy<std::thread>, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$destroy_at@Vthread@std@@@std@@YAXQEAVthread@0@@Z ; std::destroy_at<std::thread>

; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         _Ptr->~_Uty();
; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::thread> >::destroy<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z PROC ; std::_Unfancy<std::thread>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 37   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ENDP ; std::_Unfancy<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
_Location$ = 224
??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z PROC ; std::destroy_at<std::function<void __cdecl(void)> >, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Location$[rbp]
	call	??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z

; 321  :     }
; 322  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z ENDP ; std::destroy_at<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
<_Args_0>$ = 240
??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$construct_at@V?$function@$$A6AXXZ@std@@AEBV12@$0A@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@AEBV10@@Z ; std::construct_at<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 37   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	npad	1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_Al$ = 8
_My_data$ = 40
_Myfirst$ = 72
_Mylast$ = 104
_Whereoff$ = 136
_Oldsize$ = 168
_Newsize$ = 200
_Newcapacity$ = 232
_Newvec$ = 264
_Constructed_last$ = 296
_Constructed_first$ = 328
__$ArrayPad$ = 536
this$ = 576
_Whereptr$ = 584
<_Val_0>$ = 592
??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 810  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 584				; 00000248H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+616]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 811  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 812  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 813  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 814  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	QWORD PTR _Myfirst$[rbp], rax

; 815  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 816  : 
; 817  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 818  : 
; 819  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 4
	mov	QWORD PTR _Whereoff$[rbp], rax

; 820  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rcx, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 4
	mov	QWORD PTR _Oldsize$[rbp], rax

; 821  : 
; 822  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ; std::vector<std::thread,std::allocator<std::thread> >::max_size
	cmp	QWORD PTR _Oldsize$[rbp], rax
	jne	SHORT $LN2@Emplace_re

; 823  :             _Xlength();

	call	?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ ; std::vector<std::thread,std::allocator<std::thread> >::_Xlength
$LN2@Emplace_re:

; 824  :         }
; 825  : 
; 826  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rbp]
	inc	rax
	mov	QWORD PTR _Newsize$[rbp], rax

; 827  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rbp], rax

; 828  : 
; 829  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_at_least_helper@V?$allocator@Vthread@std@@@std@@@std@@YAPEAVthread@0@AEAV?$allocator@Vthread@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::thread> >
	mov	QWORD PTR _Newvec$[rbp], rax

; 830  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	lea	rax, QWORD PTR [rcx+rax+16]
	mov	QWORD PTR _Constructed_last$[rbp], rax

; 831  :         pointer _Constructed_first      = _Constructed_last;

	mov	rax, QWORD PTR _Constructed_last$[rbp]
	mov	QWORD PTR _Constructed_first$[rbp], rax

; 832  : 
; 833  :         _TRY_BEGIN
; 834  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	rax, QWORD PTR _Whereoff$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ; std::_Unfancy<std::thread>
	mov	r8, QWORD PTR <_Val_0>$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1> >

; 835  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Constructed_first$[rbp], rax

; 836  : 
; 837  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rbp], rax
	jne	SHORT $LN4@Emplace_re

; 838  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 839  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rbp]
	mov	r8, QWORD PTR _Newvec$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >

; 840  :             } else {
; 841  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             }
; 843  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 844  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rbp]
	mov	r8, QWORD PTR _Newvec$[rbp]
	mov	rdx, QWORD PTR _Whereptr$[rbp]
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >

; 845  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Newvec$[rbp]
	mov	QWORD PTR _Constructed_first$[rbp], rax

; 846  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	lea	rax, QWORD PTR [rcx+rax+16]
	mov	r9, QWORD PTR _Al$[rbp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rbp]
	call	??$_Uninitialized_move@PEAVthread@std@@V?$allocator@Vthread@std@@@2@@std@@YAPEAVthread@0@QEAV10@0PEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Uninitialized_move<std::thread *,std::allocator<std::thread> >
	npad	1
$LN5@Emplace_re:
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 847  :         }
; 848  :         _CATCH_ALL
; 849  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 850  :         _Al.deallocate(_Newvec, _Newcapacity);
; 851  :         _RERAISE;
; 852  :         _CATCH_END
; 853  : 
; 854  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rbp]
	mov	r8, QWORD PTR _Newsize$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Change_array

; 855  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	add	rcx, rax
	mov	rax, rcx

; 856  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+552]
	pop	rdi
	pop	rbp
	ret	0
$LN11@Emplace_re:
??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Al$ = 8
_My_data$ = 40
_Myfirst$ = 72
_Mylast$ = 104
_Whereoff$ = 136
_Oldsize$ = 168
_Newsize$ = 200
_Newcapacity$ = 232
_Newvec$ = 264
_Constructed_last$ = 296
_Constructed_first$ = 328
__$ArrayPad$ = 536
this$ = 576
_Whereptr$ = 584
<_Val_0>$ = 592
?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA PROC ; `std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >'::`1'::catch$0

; 848  :         _CATCH_ALL

	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
__catch$??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z$0:

; 849  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread> >

; 850  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z ; std::allocator<std::thread>::deallocate

; 851  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 852  :         _CATCH_END

	lea	rax, $LN10@catch$0
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
	int	3
?catch$0@?0???$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z@4HA ENDP ; `std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_My_data$ = 8
_Mylast$ = 40
_Result$ = 72
tv77 = 280
tv75 = 288
this$ = 336
<_Val_0>$ = 344
??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_back_with_unused_capacity<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 787  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 788  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 789  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 790  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 791  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 792  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 793  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 794  :             _ASAN_VECTOR_MODIFY(1);
; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ; std::_Unfancy<std::thread>
	mov	QWORD PTR tv77[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	QWORD PTR tv75[rbp], rax
	mov	r8, QWORD PTR <_Val_0>$[rbp]
	mov	rdx, QWORD PTR tv77[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	call	??$construct@Vthread@std@@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::construct<std::thread,`thread_pool::thread_pool'::`4'::<lambda_1> >

; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range

; 803  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rbp], rax

; 804  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16
	mov	rcx, QWORD PTR _Mylast$[rbp]
	mov	QWORD PTR [rcx], rax

; 805  : 
; 806  :         return _Result;

	mov	rax, QWORD PTR _Result$[rbp]

; 807  :     }

	lea	rsp, QWORD PTR [rbp+312]
	pop	rdi
	pop	rbp
	ret	0
??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_back_with_unused_capacity<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR <_Args_0>$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 243  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1585 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1586 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1587 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >, COMDAT

; 1585 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1586 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1587 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 224
_Bytes$ = 232
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??3@YAXPEAX@Z				; operator delete

; 256  :     } else

	jmp	SHORT $LN3@Deallocate
$LN2@Deallocate:

; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	QWORD PTR _Bytes$[rbp], 4096		; 00001000H
	jb	SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rbp]
	lea	rcx, QWORD PTR _Ptr$[rbp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN3@Deallocate:

; 265  :     }
; 266  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
_Al$ = 240
??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::thread> >, COMDAT

; 1086 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1087 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1088 :     using _Ty = typename _Alloc::value_type;
; 1089 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1090 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rbp]
	add	rax, 16
	mov	QWORD PTR _First$[rbp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rbp]
	cmp	QWORD PTR _First$[rbp], rax
	je	SHORT $LN3@Destroy_ra

; 1091 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rbp]
	call	??$_Unfancy@Vthread@std@@@std@@YAPEAVthread@0@PEAV10@@Z ; std::_Unfancy<std::thread>
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$destroy@Vthread@std@@@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SAXAEAV?$allocator@Vthread@std@@@1@QEAVthread@1@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::destroy<std::thread>

; 1092 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1093 :     }
; 1094 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 224
__param0$ = 232
__param1$ = 240
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	r8, QWORD PTR __param1$[rbp]
	mov	rdx, QWORD PTR __param0$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ
_TEXT	SEGMENT
this$ = 224
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*, COMDAT

; 166  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 167  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rbp]
	call	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*

; 168  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ
_TEXT	SEGMENT
_Block$ = 8
_Off$ = 40
tv70 = 248
this$ = 288
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*, COMDAT

; 44   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 45   :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv70[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv70[rbp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Getblock
	mov	QWORD PTR _Block$[rbp], rax

; 46   :         _Size_type _Off   = _Myoff % _Block_size;

	xor	eax, eax
	mov	QWORD PTR _Off$[rbp], rax

; 47   :         return _Mycont->_Map[_Block][_Off];

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	imul	rcx, QWORD PTR _Off$[rbp], 64		; 00000040H
	mov	rdx, QWORD PTR _Block$[rbp]
	add	rcx, QWORD PTR [rax+rdx*8]
	mov	rax, rcx

; 48   :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 224
_Off$ = 232
_Pdeque$ = 240
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >, COMDAT

; 42   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Pdeque$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Off$[rbp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$destroy_at@V?$function@$$A6AXXZ@std@@@std@@YAXQEAV?$function@$$A6AXXZ@0@@Z ; std::destroy_at<std::function<void __cdecl(void)> >

; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         _Ptr->~_Uty();
; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z PROC ; std::_Unfancy<std::function<void __cdecl(void)> >, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 37   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ENDP ; std::_Unfancy<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
_Newoff$ = 8
_Block$ = 40
tv171 = 248
tv168 = 248
tv147 = 248
tv91 = 248
tv88 = 248
tv72 = 248
tv65 = 248
tv166 = 256
tv150 = 256
tv84 = 256
tv86 = 264
this$ = 304
<_Vals_0>$ = 312
??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_internal<std::function<void __cdecl(void)> const &>, COMDAT

; 1149 :     void _Emplace_back_internal(_Tys&&... _Vals) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1150 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv65[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	rcx, QWORD PTR tv65[rbp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR [rax]
	mov	rax, rcx
	xor	eax, eax
	test	rax, rax
	jne	SHORT $LN2@Emplace_ba
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	QWORD PTR tv72[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR tv72[rbp]
	cmp	QWORD PTR [rcx], rax
	ja	SHORT $LN2@Emplace_ba

; 1151 :             _Growmap(1);

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
$LN2@Emplace_ba:

; 1152 :         }
; 1153 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	QWORD PTR tv88[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv84[rbp], rax
	mov	rax, QWORD PTR tv84[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rbp], rax
	mov	rax, QWORD PTR tv88[rbp]
	mov	rcx, QWORD PTR tv86[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv84[rbp]
	mov	QWORD PTR [rcx], rax

; 1154 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv91[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	rcx, QWORD PTR tv91[rbp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR [rax]
	mov	rax, rcx
	mov	QWORD PTR _Newoff$[rbp], rax

; 1155 :         size_type _Block  = _Getblock(_Newoff);

	mov	rdx, QWORD PTR _Newoff$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock
	mov	QWORD PTR _Block$[rbp], rax

; 1156 :         if (_Map()[_Block] == nullptr) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Block$[rbp]
	cmp	QWORD PTR [rax+rcx*8], 0
	jne	SHORT $LN3@Emplace_ba

; 1157 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv147[rbp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv147[rbp]
	call	?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::allocate
	mov	QWORD PTR tv150[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Block$[rbp]
	mov	rdx, QWORD PTR tv150[rbp]
	mov	QWORD PTR [rax+rcx*8], rdx
$LN3@Emplace_ba:

; 1158 :         }
; 1159 : 
; 1160 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	imul	rcx, rcx, 64				; 00000040H
	mov	rdx, QWORD PTR _Block$[rbp]
	add	rcx, QWORD PTR [rax+rdx*8]
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv168[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv166[rbp], rax
	mov	r8, QWORD PTR <_Vals_0>$[rbp]
	mov	rdx, QWORD PTR tv168[rbp]
	mov	rcx, QWORD PTR tv166[rbp]
	call	??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>

; 1161 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1162 : 
; 1163 :         ++_Mysize();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	QWORD PTR tv171[rbp], rax
	mov	rax, QWORD PTR tv171[rbp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR tv171[rbp]
	mov	QWORD PTR [rcx], rax

; 1164 :     }

	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_internal<std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z PROC ; std::_Destroy_in_place<std::function<void __cdecl(void)> *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z ENDP ; std::_Destroy_in_place<std::function<void __cdecl(void)> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z PROC ; std::allocator<std::function<void __cdecl(void)> *>::allocator<std::function<void __cdecl(void)> *><std::function<void __cdecl(void)> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ENDP ; std::allocator<std::function<void __cdecl(void)> *>::allocator<std::function<void __cdecl(void)> *><std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 200
tv65 = 216
_Left$ = 256
_Right$ = 264
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__394B8783_utility
	call	__CheckForDebuggerJustMyCode

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR _Left$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rbp]
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]

; 101  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z PROC ; std::addressof<std::mutex>, COMDAT

; 1585 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1586 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1587 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z ENDP ; std::addressof<std::mutex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$allocator@Vthread@std@@@std@@QEAA@XZ ; std::allocator<std::thread>::allocator<std::thread>
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::thread> >::_Vector_val<std::_Simple_types<std::thread> >
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::thread>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\type_traits
;	COMDAT ??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z PROC ; std::addressof<std::function<void __cdecl(void)> >, COMDAT

; 1585 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__86E2ECA3_type_traits
	call	__CheckForDebuggerJustMyCode

; 1586 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1587 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ENDP ; std::addressof<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 8
$T1 = 232
this$ = 288
_Al$ = 296
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	rcx, rax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	mov	QWORD PTR _New_proxy$[rbp], rax

; 1209 :         _Construct_in_place(*_New_proxy, this);

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR $T1[rbp], rax
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR _New_proxy$[rbp]
	call	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1210 :         _Myproxy            = _New_proxy;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _New_proxy$[rbp]
	mov	QWORD PTR [rax], rcx

; 1211 :         _New_proxy->_Mycont = this;

	mov	rax, QWORD PTR _New_proxy$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], rcx

; 1212 :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__394B8783_utility
	call	__CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR _New_val$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 764  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rbp]

; 765  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::function<void __cdecl(void)> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z	; std::_Get_size_of_n<16>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 971				; 000003cbH
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 971				; 000003cbH
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z
_TEXT	SEGMENT
this$ = 224
_Lck$ = 232
_Pred$ = 240
??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z PROC ; std::condition_variable::wait<`thread_pool::worker'::`5'::<lambda_1> >, COMDAT

; 567  :     void wait(unique_lock<mutex>& _Lck, _Predicate _Pred) { // wait for signal and test predicate

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode
$LN2@wait:

; 568  :         while (!_Pred()) {

	lea	rcx, QWORD PTR _Pred$[rbp]
	call	??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ ; `thread_pool::worker'::`5'::<lambda_1>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@wait

; 569  :             wait(_Lck);

	mov	rdx, QWORD PTR _Lck$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z ; std::condition_variable::wait

; 570  :         }

	jmp	SHORT $LN2@wait
$LN3@wait:

; 571  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z ENDP ; std::condition_variable::wait<`thread_pool::worker'::`5'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z
_TEXT	SEGMENT
this$ = 224
_This$ = 232
??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z PROC ; `thread_pool::worker'::`5'::<lambda_1>::<lambda_1>, COMDAT

; 43   :             this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _This$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z ENDP ; `thread_pool::worker'::`5'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ
_TEXT	SEGMENT
tv74 = 192
this$ = 240
??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ PROC ; `thread_pool::worker'::`5'::<lambda_1>::operator(), COMDAT

; 43   :             this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+224]
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	DWORD PTR tv74[rbp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv74[rbp], 1
$LN4@operator:
	movzx	eax, BYTE PTR tv74[rbp]
	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??R<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEBA@XZ ENDP ; `thread_pool::worker'::`5'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_My_data$ = 8
_Mylast$ = 40
this$ = 288
<_Val_0>$ = 296
??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_one_at_back<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 774  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 775  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 776  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 777  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 778  : 
; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rcx, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rdx, QWORD PTR <_Val_0>$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Emplace_back_with_unused_capacity@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_back_with_unused_capacity<`thread_pool::thread_pool'::`4'::<lambda_1> >
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR <_Val_0>$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Emplace_reallocate@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAPEAVthread@1@QEAV21@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_reallocate<`thread_pool::thread_pool'::`4'::<lambda_1> >
$LN1@Emplace_on:

; 784  :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_one_at_back<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z
_TEXT	SEGMENT
_Result$ = 8
this$ = 256
<_Val_0>$ = 264
??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::emplace_back<`thread_pool::thread_pool'::`4'::<lambda_1> >, COMDAT

; 860  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 861  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 862  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);

	mov	rdx, QWORD PTR <_Val_0>$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Emplace_one_at_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAVthread@1@$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Emplace_one_at_back<`thread_pool::thread_pool'::`4'::<lambda_1> >
	mov	QWORD PTR _Result$[rbp], rax

; 863  : #if _HAS_CXX17
; 864  :         return _Result;

	mov	rax, QWORD PTR _Result$[rbp]

; 865  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 866  :         (void) _Result;
; 867  : #endif // _HAS_CXX17
; 868  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::emplace_back<`thread_pool::thread_pool'::`4'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z
_TEXT	SEGMENT
this$ = 224
_This$ = 232
??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z PROC ; `thread_pool::thread_pool'::`4'::<lambda_1>::<lambda_1>, COMDAT

; 7    :         workers.emplace_back([this] { this->worker(); });

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _This$[rbp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z ENDP ; `thread_pool::thread_pool'::`4'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ
_TEXT	SEGMENT
this$ = 224
??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ PROC	; `thread_pool::thread_pool'::`4'::<lambda_1>::operator(), COMDAT

; 7    :         workers.emplace_back([this] { this->worker(); });

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	?worker@thread_pool@@AEAAXXZ		; thread_pool::worker
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??R<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEBA@XZ ENDP	; `thread_pool::thread_pool'::`4'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?worker@thread_pool@@AEAAXXZ
_TEXT	SEGMENT
task$5 = 16
lock$6 = 104
$T7 = 344
tv83 = 360
__$ArrayPad$ = 368
this$ = 416
?worker@thread_pool@@AEAAXXZ PROC			; thread_pool::worker, COMDAT

; 37   : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@worker:

; 38   :     while (true)

	xor	eax, eax
	cmp	eax, 1
	je	$LN1@worker

; 39   :     {
; 40   :         std::function<void()> task;

	lea	rcx, QWORD PTR task$5[rbp]
	call	??0?$function@$$A6AXXZ@std@@QEAA@XZ	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	npad	1

; 41   :         {
; 42   :             std::unique_lock<std::mutex> lock(this->queue_mutex);

	mov	edx, 16
	lea	rcx, QWORD PTR lock$6[rbp]
	call	?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 72					; 00000048H
	mov	rdx, rax
	lea	rcx, QWORD PTR lock$6[rbp]
	call	??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
	npad	1

; 43   :             this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv83[rbp], rax
	mov	rdx, QWORD PTR this$[rbp]
	lea	rcx, QWORD PTR $T7[rbp]
	call	??0<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@QEAA@PEAV2@@Z ; `thread_pool::worker'::`5'::<lambda_1>::<lambda_1>
	mov	r8, QWORD PTR [rax]
	lea	rdx, QWORD PTR lock$6[rbp]
	mov	rcx, QWORD PTR tv83[rbp]
	call	??$wait@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@1@V<lambda_1>@?4??worker@thread_pool@@AEAAXXZ@@Z ; std::condition_variable::wait<`thread_pool::worker'::`5'::<lambda_1> >

; 44   :             if (this->stop && this->tasks.empty())

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+224]
	test	eax, eax
	je	SHORT $LN4@worker
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@worker

; 45   :             {
; 46   :                 return;

	lea	rcx, QWORD PTR lock$6[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	npad	1
	lea	rcx, QWORD PTR task$5[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	jmp	SHORT $LN1@worker
$LN4@worker:

; 47   :             }
; 48   :             task = std::move(this->tasks.front());

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::front
	mov	rdx, rax
	lea	rcx, QWORD PTR task$5[rbp]
	call	??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z ; std::function<void __cdecl(void)>::operator=

; 49   :             this->tasks.pop();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pop
	npad	1

; 50   :         }

	lea	rcx, QWORD PTR lock$6[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>

; 51   :         task();

	lea	rcx, QWORD PTR task$5[rbp]
	call	??R?$_Func_class@X$$V@std@@QEBAXXZ	; std::_Func_class<void>::operator()
	npad	1

; 52   :     }

	lea	rcx, QWORD PTR task$5[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	jmp	$LN2@worker
$LN1@worker:

; 53   : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?worker@thread_pool@@AEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
?worker@thread_pool@@AEAAXXZ ENDP			; thread_pool::worker
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
task$5 = 16
lock$6 = 104
$T7 = 344
tv83 = 360
__$ArrayPad$ = 368
this$ = 416
?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA PROC	; `thread_pool::worker'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR task$5[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0??worker@thread_pool@@AEAAXXZ@4HA ENDP	; `thread_pool::worker'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
task$5 = 16
lock$6 = 104
$T7 = 344
tv83 = 360
__$ArrayPad$ = 368
this$ = 416
?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA PROC	; `thread_pool::worker'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR lock$6[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0??worker@thread_pool@@AEAAXXZ@4HA ENDP	; `thread_pool::worker'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\queue
;	COMDAT ?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pop, COMDAT

; 143  :     void pop() noexcept(noexcept(c.pop_front())) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50E70C21_queue
	call	__CheckForDebuggerJustMyCode

; 144  :         c.pop_front();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_front

; 145  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?pop@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXXZ ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\queue
;	COMDAT ?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
_TEXT	SEGMENT
tv68 = 192
this$ = 240
_Val$ = 248
?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::push, COMDAT

; 115  :     void push(const value_type& _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50E70C21_queue
	call	__CheckForDebuggerJustMyCode

; 116  :         c.push_back(_Val);

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	mov	rdx, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	call	?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back

; 117  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\queue
;	COMDAT ?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 224
?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::front, COMDAT

; 99   :     _NODISCARD reference front() noexcept(noexcept(c.front())) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50E70C21_queue
	call	__CheckForDebuggerJustMyCode

; 100  :         return c.front();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::front

; 101  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?front@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\queue
;	COMDAT ?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::empty, COMDAT

; 91   :     _NODISCARD_EMPTY_ADAPTOR_MEMBER bool empty() const noexcept(noexcept(c.empty())) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50E70C21_queue
	call	__CheckForDebuggerJustMyCode

; 92   :         return c.empty();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?empty@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEBA_NXZ ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\queue
;	COMDAT ??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ PROC ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >, COMDAT

; 39   :     queue() = default;

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50E70C21_queue
	call	__CheckForDebuggerJustMyCode

; 40   : 
; 41   :     explicit queue(const _Container& _Cont) : c(_Cont) {}
; 42   : 
; 43   :     explicit queue(_Container&& _Cont) noexcept(is_nothrow_move_constructible_v<_Container>) // strengthened
; 44   :         : c(_STD move(_Cont)) {}
; 45   : 
; 46   : #if _HAS_CXX23
; 47   :     template <class _InIt, enable_if_t<_Is_iterator_v<_InIt>, int> = 0>
; 48   :     queue(_InIt _First, _InIt _Last) noexcept(is_nothrow_constructible_v<_Container, _InIt, _InIt>) // strengthened
; 49   :         : c(_STD move(_First), _STD move(_Last)) {}
; 50   : 
; 51   : #ifdef __cpp_lib_concepts
; 52   :     template <_Container_compatible_range<_Ty> _Rng>
; 53   :     queue(from_range_t, _Rng&& _Range) : c(_RANGES to<_Container>(_STD forward<_Rng>(_Range))) {}
; 54   : #endif // defined(__cpp_lib_concepts)
; 55   : #endif // _HAS_CXX23
; 56   : 
; 57   :     template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
; 58   :     explicit queue(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>) // strengthened
; 59   :         : c(_Al) {}
; 60   : 
; 61   :     template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
; 62   :     queue(const _Container& _Cont, const _Alloc& _Al) : c(_Cont, _Al) {}
; 63   : 
; 64   :     template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
; 65   :     queue(_Container&& _Cont, const _Alloc& _Al) noexcept(
; 66   :         is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) // strengthened
; 67   :         : c(_STD move(_Cont), _Al) {}
; 68   : 
; 69   :     template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
; 70   :     queue(const queue& _Right, const _Alloc& _Al) : c(_Right.c, _Al) {}
; 71   : 
; 72   :     template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
; 73   :     queue(queue&& _Right, const _Alloc& _Al) noexcept(
; 74   :         is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) // strengthened
; 75   :         : c(_STD move(_Right.c), _Al) {}
; 76   : 
; 77   : #if _HAS_CXX23
; 78   :     template <class _InIt, class _Alloc,
; 79   :         enable_if_t<conjunction_v<_Is_iterator<_InIt>, uses_allocator<_Container, _Alloc>>, int> = 0>
; 80   :     queue(_InIt _First, _InIt _Last, const _Alloc& _Al) noexcept(
; 81   :         is_nothrow_constructible_v<_Container, _InIt, _InIt, const _Alloc&>) // strengthened
; 82   :         : c(_STD move(_First), _STD move(_Last), _Al) {}
; 83   : 
; 84   : #ifdef __cpp_lib_concepts
; 85   :     template <_Container_compatible_range<_Ty> _Rng, class _Alloc>
; 86   :     queue(from_range_t, _Rng&& _Range, const _Alloc& _Al)
; 87   :         : c(_RANGES to<_Container>(_STD forward<_Rng>(_Range), _Al)) {}
; 88   : #endif // defined(__cpp_lib_concepts)
; 89   : #endif // _HAS_CXX23
; 90   : 
; 91   :     _NODISCARD_EMPTY_ADAPTOR_MEMBER bool empty() const noexcept(noexcept(c.empty())) /* strengthened */ {
; 92   :         return c.empty();
; 93   :     }
; 94   : 
; 95   :     _NODISCARD size_type size() const noexcept(noexcept(c.size())) /* strengthened */ {
; 96   :         return c.size();
; 97   :     }
; 98   : 
; 99   :     _NODISCARD reference front() noexcept(noexcept(c.front())) /* strengthened */ {
; 100  :         return c.front();
; 101  :     }
; 102  : 
; 103  :     _NODISCARD const_reference front() const noexcept(noexcept(c.front())) /* strengthened */ {
; 104  :         return c.front();
; 105  :     }
; 106  : 
; 107  :     _NODISCARD reference back() noexcept(noexcept(c.back())) /* strengthened */ {
; 108  :         return c.back();
; 109  :     }
; 110  : 
; 111  :     _NODISCARD const_reference back() const noexcept(noexcept(c.back())) /* strengthened */ {
; 112  :         return c.back();
; 113  :     }
; 114  : 
; 115  :     void push(const value_type& _Val) {
; 116  :         c.push_back(_Val);
; 117  :     }
; 118  : 
; 119  :     void push(value_type&& _Val) {
; 120  :         c.push_back(_STD move(_Val));
; 121  :     }
; 122  : 
; 123  : #if _HAS_CXX23 && defined(__cpp_lib_concepts) // TRANSITION, GH-395
; 124  :     template <_Container_compatible_range<_Ty> _Rng>
; 125  :     void push_range(_Rng&& _Range) {
; 126  :         if constexpr (requires { c.append_range(_Range); }) {
; 127  :             c.append_range(_Range);
; 128  :         } else {
; 129  :             _RANGES copy(_Range, back_insert_iterator{c});
; 130  :         }
; 131  :     }
; 132  : #endif // _HAS_CXX23 && defined(__cpp_lib_concepts)
; 133  : 
; 134  :     template <class... _Valty>
; 135  :     decltype(auto) emplace(_Valty&&... _Val) {
; 136  : #if _HAS_CXX17
; 137  :         return c.emplace_back(_STD forward<_Valty>(_Val)...);
; 138  : #else // ^^^ C++17 or newer / C++14 vvv
; 139  :         c.emplace_back(_STD forward<_Valty>(_Val)...);
; 140  : #endif // _HAS_CXX17
; 141  :     }
; 142  : 
; 143  :     void pop() noexcept(noexcept(c.pop_front())) /* strengthened */ {
; 144  :         c.pop_front();
; 145  :     }
; 146  : 
; 147  :     void swap(queue& _Right) noexcept(_Is_nothrow_swappable<_Container>::value) {
; 148  :         using _STD swap;
; 149  :         swap(c, _Right.c); // intentional ADL
; 150  :     }
; 151  : 
; 152  :     _NODISCARD const _Container& _Get_container() const noexcept {
; 153  :         return c;
; 154  :     }
; 155  : 
; 156  : protected:
; 157  :     _Container c{};

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >

; 39   :     queue() = default;

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ ENDP ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1531 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1532 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1527 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1528 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 224
?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize, COMDAT

; 1682 :     const size_type& _Mysize() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1683 :         return _Get_data()._Mysize;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 32					; 00000020H

; 1684 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 224
?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize, COMDAT

; 1678 :     size_type& _Mysize() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1679 :         return _Get_data()._Mysize;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 32					; 00000020H

; 1680 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 224
?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff, COMDAT

; 1674 :     const size_type& _Myoff() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1675 :         return _Get_data()._Myoff;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 24

; 1676 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 224
?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff, COMDAT

; 1670 :     size_type& _Myoff() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1671 :         return _Get_data()._Myoff;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 24

; 1672 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 224
?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize, COMDAT

; 1662 :     size_type& _Mapsize() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1663 :         return _Get_data()._Mapsize;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 16

; 1664 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map, COMDAT

; 1654 :     _Mapptr& _Map() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1655 :         return _Get_data()._Map;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	add	rax, 8

; 1656 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data, COMDAT

; 1650 :     const _Scary_val& _Get_data() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1651 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]

; 1652 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data, COMDAT

; 1646 :     _Scary_val& _Get_data() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1647 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]

; 1648 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal, COMDAT

; 1642 :     const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1643 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first

; 1644 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal, COMDAT

; 1638 :     _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1639 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first

; 1640 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_all, COMDAT

; 1634 :     void _Orphan_all() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1635 :         _Get_data()._Orphan_all();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	mov	rcx, rax
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 1636 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv70 = 192
this$ = 240
_Off$ = 248
?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock, COMDAT

; 1630 :     size_type _Getblock(size_type _Off) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1631 :         return _Get_data()._Getblock(_Off);

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	mov	QWORD PTR tv70[rbp], rax
	mov	rdx, QWORD PTR _Off$[rbp]
	mov	rcx, QWORD PTR tv70[rbp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Getblock

; 1632 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z
_TEXT	SEGMENT
_Offhigh$ = 8
_Lock$ = 36
_Pnext$ = 72
_Pnextoff$4 = 104
tv65 = 312
tv71 = 320
__$ArrayPad$ = 328
this$ = 368
_Offlo$ = 376
?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off, COMDAT

; 1610 :     void _Orphan_off(size_type _Offlo) const noexcept { // orphan iterators with specified offset(s)

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1611 :         size_type _Offhigh = _Myoff() + _Mysize() <= _Offlo + 1 ? static_cast<size_type>(-1) : _Offlo;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv65[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	rcx, QWORD PTR tv65[rbp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR [rax]
	mov	rax, rcx
	mov	rcx, QWORD PTR _Offlo$[rbp]
	inc	rcx
	cmp	rax, rcx
	ja	SHORT $LN9@Orphan_off
	mov	QWORD PTR tv71[rbp], -1
	jmp	SHORT $LN10@Orphan_off
$LN9@Orphan_off:
	mov	rax, QWORD PTR _Offlo$[rbp]
	mov	QWORD PTR tv71[rbp], rax
$LN10@Orphan_off:
	mov	rax, QWORD PTR tv71[rbp]
	mov	QWORD PTR _Offhigh$[rbp], rax

; 1612 :         if (_Offlo == _Myoff()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Offlo$[rbp], rax
	jne	SHORT $LN4@Orphan_off

; 1613 :             _Offlo = 0;

	mov	QWORD PTR _Offlo$[rbp], 0
$LN4@Orphan_off:

; 1614 :         }
; 1615 : 
; 1616 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1617 :         _Iterator_base12** _Pnext = &_Get_data()._Myproxy->_Myfirstiter;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	mov	QWORD PTR _Pnext$[rbp], rax
$LN2@Orphan_off:

; 1618 :         while (*_Pnext) {

	mov	rax, QWORD PTR _Pnext$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Orphan_off

; 1619 :             const auto _Pnextoff = static_cast<const_iterator&>(**_Pnext)._Myoff;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnextoff$4[rbp], rax

; 1620 :             if (_Pnextoff < _Offlo || _Offhigh < _Pnextoff) {

	mov	rax, QWORD PTR _Offlo$[rbp]
	cmp	QWORD PTR _Pnextoff$4[rbp], rax
	jb	SHORT $LN7@Orphan_off
	mov	rax, QWORD PTR _Pnextoff$4[rbp]
	cmp	QWORD PTR _Offhigh$[rbp], rax
	jae	SHORT $LN5@Orphan_off
$LN7@Orphan_off:

; 1621 :                 _Pnext = &(*_Pnext)->_Mynextiter;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	mov	QWORD PTR _Pnext$[rbp], rax

; 1622 :             } else { // orphan the iterator

	jmp	SHORT $LN6@Orphan_off
$LN5@Orphan_off:

; 1623 :                 (*_Pnext)->_Myproxy = nullptr;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rax], 0

; 1624 :                 *_Pnext             = (*_Pnext)->_Mynextiter;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax
$LN6@Orphan_off:

; 1625 :             }
; 1626 :         }

	jmp	SHORT $LN2@Orphan_off
$LN3@Orphan_off:

; 1627 :     }

	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+344]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Almap$ = 4
_Block$4 = 40
tv146 = 248
tv130 = 248
tv144 = 256
tv128 = 256
__$ArrayPad$ = 264
this$ = 304
?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy, COMDAT

; 1586 :     void _Tidy() noexcept { // free all storage

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 22
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+344]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1587 :         _Orphan_all();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_all

; 1588 : 
; 1589 :         _Alpty _Almap(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Almap$[rbp]
	call	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::function<void __cdecl(void)> *>::allocator<std::function<void __cdecl(void)> *><std::function<void __cdecl(void)> >
$LN2@Tidy:

; 1590 :         while (!empty()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Tidy

; 1591 :             pop_back();

	mov	rcx, QWORD PTR this$[rbp]
	call	?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_back

; 1592 :         }

	jmp	SHORT $LN2@Tidy
$LN3@Tidy:

; 1593 : 
; 1594 :         if (_Map() != nullptr) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	cmp	QWORD PTR [rax], 0
	je	$LN7@Tidy

; 1595 :             for (size_type _Block = _Mapsize(); _Block > 0;) { // free storage for a block and destroy pointer

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Block$4[rbp], rax
$LN4@Tidy:
	cmp	QWORD PTR _Block$4[rbp], 0
	jbe	$LN5@Tidy

; 1596 :                 if (_Map()[--_Block]) { // free block

	mov	rax, QWORD PTR _Block$4[rbp]
	dec	rax
	mov	QWORD PTR _Block$4[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Block$4[rbp]
	cmp	QWORD PTR [rax+rcx*8], 0
	je	SHORT $LN8@Tidy

; 1597 :                     _Getal().deallocate(_Map()[_Block], _Block_size);

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv130[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Block$4[rbp]
	mov	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv128[rbp], rax
	mov	r8d, 1
	mov	rdx, QWORD PTR tv128[rbp]
	mov	rcx, QWORD PTR tv130[rbp]
	call	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate
$LN8@Tidy:

; 1598 :                 }
; 1599 :                 _Destroy_in_place(_Map()[_Block]); // destroy pointer to block

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Block$4[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAV?$function@$$A6AXXZ@std@@@std@@YAXAEAPEAV?$function@$$A6AXXZ@0@@Z ; std::_Destroy_in_place<std::function<void __cdecl(void)> *>

; 1600 :             }

	jmp	$LN4@Tidy
$LN5@Tidy:

; 1601 : 
; 1602 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for map

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv146[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv144[rbp], rax
	mov	r8, QWORD PTR tv146[rbp]
	mov	rdx, QWORD PTR tv144[rbp]
	lea	rcx, QWORD PTR _Almap$[rbp]
	call	?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> *>::deallocate
$LN7@Tidy:

; 1603 :         }
; 1604 : 
; 1605 :         _Mapsize() = 0;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	QWORD PTR [rax], 0

; 1606 :         _Map()     = nullptr;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	QWORD PTR [rax], 0

; 1607 :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	npad	1
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
_Almap$ = 4
_Newsize$ = 40
_Myboff$ = 72
_Newmap$ = 104
_Myptr$ = 136
tv227 = 344
tv222 = 344
tv199 = 344
tv192 = 344
tv177 = 344
tv158 = 344
tv129 = 344
tv73 = 344
tv220 = 352
tv211 = 352
tv190 = 352
tv175 = 352
tv156 = 352
tv143 = 352
tv209 = 360
tv141 = 360
__$ArrayPad$ = 368
this$ = 416
_Count$ = 424
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap, COMDAT

; 1546 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1547 :         static_assert(_Minimum_map_size > 1, "The _Xlen() test should always be performed.");
; 1548 : 
; 1549 :         _Alpty _Almap(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Almap$[rbp]
	call	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::function<void __cdecl(void)> *>::allocator<std::function<void __cdecl(void)> *><std::function<void __cdecl(void)> >

; 1550 :         size_type _Newsize = _Mapsize() > 0 ? _Mapsize() : 1;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	cmp	QWORD PTR [rax], 0
	jbe	SHORT $LN10@Growmap
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rbp], rax
	jmp	SHORT $LN11@Growmap
$LN10@Growmap:
	mov	QWORD PTR tv73[rbp], 1
$LN11@Growmap:
	mov	rax, QWORD PTR tv73[rbp]
	mov	QWORD PTR _Newsize$[rbp], rax
$LN2@Growmap:

; 1551 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _Minimum_map_size) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newsize$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR _Count$[rbp]
	jb	SHORT $LN4@Growmap
	cmp	QWORD PTR _Newsize$[rbp], 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1552 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1553 :             if (max_size() / _Block_size - _Newsize < _Newsize) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
	sub	rax, QWORD PTR _Newsize$[rbp]
	cmp	rax, QWORD PTR _Newsize$[rbp]
	jae	SHORT $LN5@Growmap

; 1554 :                 _Xlen(); // result too long

	call	?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlen
$LN5@Growmap:

; 1555 :             }
; 1556 : 
; 1557 :             _Newsize *= 2;

	mov	rax, QWORD PTR _Newsize$[rbp]
	shl	rax, 1
	mov	QWORD PTR _Newsize$[rbp], rax

; 1558 :         }

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1559 : 
; 1560 :         size_type _Myboff = _Myoff() / _Block_size;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Myboff$[rbp], rax

; 1561 :         _Mapptr _Newmap   = _Allocate_at_least_helper(_Almap, _Newsize);

	lea	rdx, QWORD PTR _Newsize$[rbp]
	lea	rcx, QWORD PTR _Almap$[rbp]
	call	??$_Allocate_at_least_helper@V?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@PEAV?$function@$$A6AXXZ@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> *> >
	mov	QWORD PTR _Newmap$[rbp], rax

; 1562 :         _Mapptr _Myptr    = _Newmap + _Myboff;

	mov	rax, QWORD PTR _Newmap$[rbp]
	mov	rcx, QWORD PTR _Myboff$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Myptr$[rbp], rax

; 1563 : 
; 1564 :         _Count = _Newsize - _Mapsize();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newsize$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rbp], rax

; 1565 : 
; 1566 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	QWORD PTR tv129[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv129[rbp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv143[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Myboff$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv141[rbp], rax
	mov	r8, QWORD PTR _Myptr$[rbp]
	mov	rdx, QWORD PTR tv143[rbp]
	mov	rcx, QWORD PTR tv141[rbp]
	call	??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _Myptr$[rbp], rax

; 1567 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

	mov	rax, QWORD PTR _Count$[rbp]
	cmp	QWORD PTR _Myboff$[rbp], rax
	ja	$LN6@Growmap

; 1568 :             _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Myboff$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv158[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv156[rbp], rax
	mov	r8, QWORD PTR _Myptr$[rbp]
	mov	rdx, QWORD PTR tv158[rbp]
	mov	rcx, QWORD PTR tv156[rbp]
	call	??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _Myptr$[rbp], rax

; 1569 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new

	mov	rax, QWORD PTR _Myboff$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR _Myptr$[rbp]
	call	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>

; 1570 :             _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new

	mov	rdx, QWORD PTR _Myboff$[rbp]
	mov	rcx, QWORD PTR _Newmap$[rbp]
	call	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>

; 1571 :         } else { // increment not greater than offset of initial block

	jmp	$LN7@Growmap
$LN6@Growmap:

; 1572 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv177[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv175[rbp], rax
	mov	r8, QWORD PTR _Myptr$[rbp]
	mov	rdx, QWORD PTR tv177[rbp]
	mov	rcx, QWORD PTR tv175[rbp]
	call	??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>

; 1573 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Myboff$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv192[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv190[rbp], rax
	mov	r8, QWORD PTR _Newmap$[rbp]
	mov	rdx, QWORD PTR tv192[rbp]
	mov	rcx, QWORD PTR tv190[rbp]
	call	??$uninitialized_copy@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@0PEAPEAV10@@Z ; std::uninitialized_copy<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>
	mov	QWORD PTR _Myptr$[rbp], rax

; 1574 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block

	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Myptr$[rbp]
	call	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAV?$function@$$A6AXXZ@std@@_K@std@@YAPEAPEAV?$function@$$A6AXXZ@0@PEAPEAV10@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<std::function<void __cdecl(void)> * *,unsigned __int64>
$LN7@Growmap:

; 1575 :         }
; 1576 : 
; 1577 :         if (_Map() != nullptr) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	cmp	QWORD PTR [rax], 0
	je	$LN8@Growmap

; 1578 :             _Destroy_range(_Map(), _Map() + _Mapsize());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	QWORD PTR tv199[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv199[rbp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv211[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv209[rbp], rax
	mov	rdx, QWORD PTR tv211[rbp]
	mov	rcx, QWORD PTR tv209[rbp]
	call	??$_Destroy_range@PEAPEAV?$function@$$A6AXXZ@std@@PEAPEAV12@@std@@YAXPEAPEAV?$function@$$A6AXXZ@0@QEAPEAV10@@Z ; std::_Destroy_range<std::function<void __cdecl(void)> * *,std::function<void __cdecl(void)> * *>

; 1579 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for old

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv222[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv220[rbp], rax
	mov	r8, QWORD PTR tv222[rbp]
	mov	rdx, QWORD PTR tv220[rbp]
	lea	rcx, QWORD PTR _Almap$[rbp]
	call	?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> *>::deallocate
$LN8@Growmap:

; 1580 :         }
; 1581 : 
; 1582 :         _Map() = _Newmap; // point at new

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rcx, QWORD PTR _Newmap$[rbp]
	mov	QWORD PTR [rax], rcx

; 1583 :         _Mapsize() += _Count;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mapsize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mapsize
	mov	QWORD PTR tv227[rbp], rax
	mov	rax, QWORD PTR tv227[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR tv227[rbp]
	mov	QWORD PTR [rcx], rax
$LN9@Growmap:

; 1584 :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
?_Growmap@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAX_K@Z ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlen, COMDAT

; 1538 :     [[noreturn]] static void _Xlen() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1539 :         _Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1540 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Xlen@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_Newoff$1 = 8
_Block$2 = 40
tv145 = 248
tv142 = 248
tv84 = 248
tv140 = 256
this$ = 304
?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_back, COMDAT

; 1191 :     void pop_back() noexcept /* strengthened */ {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1192 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1193 :         if (empty()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_back
$LN4@pop_back:

; 1194 :             _STL_REPORT_ERROR("deque empty before pop");

	lea	rax, OFFSET FLAT:??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1194				; 000004aaH
	lea	rdx, OFFSET FLAT:??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN9@pop_back
	int	3
	xor	eax, eax
$LN9@pop_back:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1194				; 000004aaH
	lea	r8, OFFSET FLAT:??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@pop_back

; 1195 :         } else { // something to erase, do it

	jmp	$LN6@pop_back
$LN5@pop_back:

; 1196 :             size_type _Newoff = _Myoff() + _Mysize() - 1;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv84[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	rcx, QWORD PTR tv84[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR _Newoff$1[rbp], rax

; 1197 :             _Orphan_off(_Newoff);

	mov	rdx, QWORD PTR _Newoff$1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off

; 1198 :             size_type _Block = _Getblock(_Newoff);

	mov	rdx, QWORD PTR _Newoff$1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock
	mov	QWORD PTR _Block$2[rbp], rax

; 1199 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size));

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	imul	rcx, rcx, 64				; 00000040H
	mov	rdx, QWORD PTR _Block$2[rbp]
	add	rcx, QWORD PTR [rax+rdx*8]
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv142[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv140[rbp], rax
	mov	rdx, QWORD PTR tv142[rbp]
	mov	rcx, QWORD PTR tv140[rbp]
	call	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >

; 1200 :             if (--_Mysize() == 0) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	QWORD PTR tv145[rbp], rax
	mov	rax, QWORD PTR tv145[rbp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR tv145[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv145[rbp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN6@pop_back

; 1201 :                 _Myoff() = 0;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR [rax], 0
$LN6@pop_back:

; 1202 :             }
; 1203 :         }
; 1204 : 
; 1205 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL < 2 vvv
; 1206 :         size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1207 :         size_type _Block  = _Getblock(_Newoff);
; 1208 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size));
; 1209 :         if (--_Mysize() == 0) {
; 1210 :             _Myoff() = 0;
; 1211 :         }
; 1212 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL < 2 ^^^
; 1213 :     }

	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
?pop_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
_TEXT	SEGMENT
this$ = 224
_Val$ = 232
?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back, COMDAT

; 1186 :     void push_back(const _Ty& _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1187 :         _Orphan_all();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_all

; 1188 :         _Emplace_back_internal(_Val);

	mov	rdx, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Emplace_back_internal@AEBV?$function@$$A6AXXZ@std@@@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXAEBV?$function@$$A6AXXZ@1@@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_internal<std::function<void __cdecl(void)> const &>

; 1189 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?push_back@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_Block$1 = 8
tv158 = 216
tv152 = 216
tv145 = 216
tv142 = 224
tv140 = 232
this$ = 272
?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_front, COMDAT

; 1121 :     void pop_front() noexcept /* strengthened */ {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1122 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1123 :         if (empty()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_front
$LN4@pop_front:

; 1124 :             _STL_REPORT_ERROR("deque empty before pop");

	lea	rax, OFFSET FLAT:??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1124				; 00000464H
	lea	rdx, OFFSET FLAT:??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN10@pop_front
	int	3
	xor	eax, eax
$LN10@pop_front:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1124				; 00000464H
	lea	r8, OFFSET FLAT:??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@pop_front

; 1125 :         } else { // something to erase, do it

	jmp	$LN6@pop_front
$LN5@pop_front:

; 1126 :             _Orphan_off(_Myoff());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_off@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAX_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_off

; 1127 :             size_type _Block = _Getblock(_Myoff());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getblock@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getblock
	mov	QWORD PTR _Block$1[rbp], rax

; 1128 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % _Block_size));

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Map@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAPEAPEAV?$function@$$A6AXXZ@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Map
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv158[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	xor	eax, eax
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR _Block$1[rbp]
	mov	rdx, QWORD PTR tv158[rbp]
	add	rax, QWORD PTR [rdx+rcx*8]
	mov	rcx, rax
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv142[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv140[rbp], rax
	mov	rdx, QWORD PTR tv142[rbp]
	mov	rcx, QWORD PTR tv140[rbp]
	call	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >

; 1129 :             if (--_Mysize() == 0) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	mov	QWORD PTR tv145[rbp], rax
	mov	rax, QWORD PTR tv145[rbp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR tv145[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv145[rbp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN7@pop_front

; 1130 :                 _Myoff() = 0;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR [rax], 0

; 1131 :             } else {

	jmp	SHORT $LN6@pop_front
$LN7@pop_front:

; 1132 :                 ++_Myoff();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	QWORD PTR tv152[rbp], rax
	mov	rax, QWORD PTR tv152[rbp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR tv152[rbp]
	mov	QWORD PTR [rcx], rax
$LN6@pop_front:

; 1133 :             }
; 1134 :         }
; 1135 : 
; 1136 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL < 2 vvv
; 1137 :         size_type _Block = _Getblock(_Myoff());
; 1138 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % _Block_size));
; 1139 :         if (--_Mysize() == 0) {
; 1140 :             _Myoff() = 0;
; 1141 :         } else {
; 1142 :             ++_Myoff();
; 1143 :         }
; 1144 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL < 2 ^^^
; 1145 :     }

	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
?pop_front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::pop_front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 272
?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::front, COMDAT

; 1085 :     _NODISCARD reference front() noexcept /* strengthened */ {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode
$LN4@front:

; 1086 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1087 :         _STL_VERIFY(!empty(), "front() called on empty deque");

	mov	rcx, QWORD PTR this$[rbp]
	call	?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@front
	jmp	SHORT $LN9@front
$LN7@front:
	lea	rax, OFFSET FLAT:??_C@_0BO@PEOHNLIM@front?$CI?$CJ?5called?5on?5empty?5deque@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1087				; 0000043fH
	lea	rdx, OFFSET FLAT:??_C@_0GA@OFLCKJGB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN11@front
	int	3
	xor	eax, eax
$LN11@front:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1087				; 0000043fH
	lea	r8, OFFSET FLAT:??_C@_1MA@KDLMHFEF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1EA@EELNAHHD@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@front
$LN9@front:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@front

; 1088 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1089 : 
; 1090 :         return *_Unchecked_begin();

	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
	mov	rcx, rax
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >::operator*

; 1091 :     }

	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
?front@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAAEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 192
this$ = 240
?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty, COMDAT

; 1045 :     _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1046 :         return _Mysize() == 0;

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mysize@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEB_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Mysize
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv67[rbp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv67[rbp]

; 1047 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?empty@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_NXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 200
$T2 = 232
this$ = 288
?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size, COMDAT

; 1040 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 1041 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
	mov	QWORD PTR $T1[rbp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T2[rbp], rax
	lea	rdx, QWORD PTR $T1[rbp]
	lea	rcx, QWORD PTR $T2[rbp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1042 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1043 :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv81 = 192
tv79 = 200
this$ = 240
__$ReturnUdt$ = 248
?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin, COMDAT

; 947  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 948  :         return _Unchecked_iterator(_Myoff(), _STD addressof(_Get_data()));

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	mov	rcx, rax
	call	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > > >
	mov	QWORD PTR tv81[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Myoff@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEA_KXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Myoff
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rbp], rax
	mov	r8, QWORD PTR tv81[rbp]
	mov	rdx, QWORD PTR tv79[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 949  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_begin@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Proxy_allocator$ = 4
$T4 = 228
__$ArrayPad$ = 248
this$ = 288
??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 905  :     ~deque() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 906  :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy

; 907  :         _Alproxy_ty _Proxy_allocator(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Proxy_allocator$[rbp]
	call	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::function<void __cdecl(void)> >

; 908  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

	mov	QWORD PTR $T4[rbp], 0
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	lea	rdx, QWORD PTR $T4[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Proxy_allocator$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 909  :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??1?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 196
$T2 = 228
tv85 = 248
tv69 = 248
tv83 = 256
this$ = 304
??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 613  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >,1><>

; 614  :         _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Get_data@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Get_data
	mov	QWORD PTR tv85[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rbp]
	call	??$?0V?$function@$$A6AXXZ@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::function<void __cdecl(void)> >
	mov	QWORD PTR tv83[rbp], rax
	mov	rdx, QWORD PTR tv83[rbp]
	mov	rcx, QWORD PTR tv85[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 615  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+280]
	pop	rdi
	pop	rbp
	ret	0
??0?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 224
_Off$ = 232
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Getblock, COMDAT

; 560  :     size_type _Getblock(size_type _Off) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode

; 561  :         // NB: _Mapsize and _Block_size are guaranteed to be powers of 2
; 562  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+16]
	dec	rax
	mov	rcx, QWORD PTR _Off$[rbp]
	and	rcx, rax
	mov	rax, rcx

; 563  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEBA_K_K@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >, COMDAT

; 558  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B3D148E0_deque
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Container_base12@std@@QEAA@XZ	; std::_Container_base12::_Container_base12
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >::_Deque_val<std::_Deque_simple_types<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z PROC		; std::function<void __cdecl(void)>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z ENDP		; std::function<void __cdecl(void)>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$function@$$A6AXXZ@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$function@$$A6AXXZ@std@@QEAA@XZ PROC		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$function@$$A6AXXZ@std@@QEAA@XZ ENDP		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 224
_Right$ = 232
??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z PROC	; std::function<void __cdecl(void)>::operator=, COMDAT

; 1060 :     function& operator=(function&& _Right) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 1061 :         if (this != _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rbp]
	call	??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> >
	cmp	QWORD PTR this$[rbp], rax
	je	SHORT $LN2@operator

; 1062 :             this->_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ	; std::_Func_class<void>::_Tidy

; 1063 :             this->_Reset_move(_STD move(_Right));

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ; std::_Func_class<void>::_Reset_move
$LN2@operator:

; 1064 :         }
; 1065 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1066 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??4?$function@$$A6AXXZ@std@@QEAAAEAV01@$$QEAV01@@Z ENDP	; std::function<void __cdecl(void)>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
_Right$ = 232
??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT

; 1017 :     function(const function& _Right) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::_Func_class<void>
	npad	1

; 1018 :         this->_Reset_copy(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ; std::_Func_class<void>::_Reset_copy
	npad	1

; 1019 :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
this$ = 224
_Right$ = 232
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$function@$$A6AXXZ@std@@QEAA@XZ PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT

; 1013 :     function() noexcept {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::_Func_class<void>
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$function@$$A6AXXZ@std@@QEAA@XZ ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z PROC ; std::_Func_class<void>::_Set, COMDAT

; 977  :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 978  :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 979  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ENDP ; std::_Func_class<void>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ PROC ; std::_Func_class<void>::_Getimpl, COMDAT

; 973  :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 974  :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rcx+rax]

; 975  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ENDP ; std::_Func_class<void>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ
_TEXT	SEGMENT
tv68 = 192
this$ = 240
?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ PROC		; std::_Func_class<void>::_Local, COMDAT

; 961  :     bool _Local() const noexcept { // test for locally stored copy of object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 962  :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	rcx, QWORD PTR this$[rbp]
	cmp	rax, rcx
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv68[rbp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv68[rbp], 0
$LN4@Local:
	movzx	eax, BYTE PTR tv68[rbp]

; 963  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ENDP		; std::_Func_class<void>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ
_TEXT	SEGMENT
tv71 = 192
tv81 = 200
tv78 = 208
this$ = 256
?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ PROC		; std::_Func_class<void>::_Tidy, COMDAT

; 930  :     void _Tidy() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 931  :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Tidy

; 932  :             _Getimpl()->_Delete_this(!_Local());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv71[rbp], rax
	mov	rax, QWORD PTR tv71[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv81[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ; std::_Func_class<void>::_Local
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv78[rbp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv78[rbp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv78[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	call	QWORD PTR tv81[rbp]

; 933  :             _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
$LN2@Tidy:

; 934  :         }
; 935  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ ENDP		; std::_Func_class<void>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z
_TEXT	SEGMENT
tv76 = 192
tv83 = 200
this$ = 240
_Right$ = 248
?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z PROC ; std::_Func_class<void>::_Reset_move, COMDAT

; 877  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 878  :         if (!_Right._Empty()) {

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	$LN2@Reset_move

; 879  :             if (_Right._Local()) { // move and tidy

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ; std::_Func_class<void>::_Local
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Reset_move

; 880  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv76[rbp], rax
	mov	rax, QWORD PTR tv76[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv83[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv76[rbp]
	call	QWORD PTR tv83[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set

; 881  :                 _Right._Tidy();

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ	; std::_Func_class<void>::_Tidy

; 882  :             } else { // steal from _Right

	jmp	SHORT $LN2@Reset_move
$LN3@Reset_move:

; 883  :                 _Set(_Right._Getimpl());

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set

; 884  :                 _Right._Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
$LN2@Reset_move:

; 885  :             }
; 886  :         }
; 887  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ENDP ; std::_Func_class<void>::_Reset_move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z
_TEXT	SEGMENT
tv72 = 192
tv79 = 200
this$ = 240
_Right$ = 248
?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z PROC ; std::_Func_class<void>::_Reset_copy, COMDAT

; 871  :     void _Reset_copy(const _Func_class& _Right) { // copy _Right's stored object

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 872  :         if (!_Right._Empty()) {

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset_copy

; 873  :             _Set(_Right._Getimpl()->_Copy(&_Mystorage));

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv72[rbp], rax
	mov	rax, QWORD PTR tv72[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv72[rbp]
	call	QWORD PTR tv79[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
$LN2@Reset_copy:

; 874  :         }
; 875  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ENDP ; std::_Func_class<void>::_Reset_copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 192
this$ = 240
?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ PROC		; std::_Func_class<void>::_Empty, COMDAT

; 867  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 868  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rbp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rbp]

; 869  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ENDP		; std::_Func_class<void>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??1?$_Func_class@X$$V@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Func_class@X$$V@std@@QEAA@XZ PROC			; std::_Func_class<void>::~_Func_class<void>, COMDAT

; 857  :     ~_Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 858  :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ	; std::_Func_class<void>::_Tidy

; 859  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Func_class@X$$V@std@@QEAA@XZ ENDP			; std::_Func_class<void>::~_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??R?$_Func_class@X$$V@std@@QEBAXXZ
_TEXT	SEGMENT
_Impl$ = 8
this$ = 256
??R?$_Func_class@X$$V@std@@QEBAXXZ PROC			; std::_Func_class<void>::operator(), COMDAT

; 849  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 850  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 851  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
$LN2@operator:

; 852  :         }
; 853  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR _Impl$[rbp], rax

; 854  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Impl$[rbp]
	call	QWORD PTR [rax+16]
$LN3@operator:

; 855  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??R?$_Func_class@X$$V@std@@QEBAXXZ ENDP			; std::_Func_class<void>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\functional
;	COMDAT ??0?$_Func_class@X$$V@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$_Func_class@X$$V@std@@QEAA@XZ PROC			; std::_Func_class<void>::_Func_class<void>, COMDAT

; 845  :     _Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7931BFA6_functional
	call	__CheckForDebuggerJustMyCode

; 846  :         _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set

; 847  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Func_class@X$$V@std@@QEAA@XZ ENDP			; std::_Func_class<void>::_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> *>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAPEAPEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> *>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 971				; 000003cbH
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 971				; 000003cbH
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rbp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@PEAV?$function@$$A6AXXZ@std@@@std@@QEAAXQEAPEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 224
?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 738  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z	; std::_Get_size_of_n<64>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 971				; 000003cbH
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 971				; 000003cbH
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 64		; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ PROC ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1531 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1532 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1527 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1528 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::thread> >::_Vector_val<std::_Simple_types<std::thread> >, COMDAT

; 396  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Container_base12@std@@QEAA@XZ	; std::_Container_base12::_Container_base12
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::thread> >::_Vector_val<std::_Simple_types<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Getal, COMDAT

; 2192 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2193 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@Vthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first

; 2194 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Getal, COMDAT

; 2188 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2189 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Get_first

; 2190 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
_TEXT	SEGMENT
this$ = 224
_First$ = 232
_Last$ = 240
?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range, COMDAT

; 2173 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2174 :         // orphan iterators within specified (inclusive) range
; 2175 : #if _HAS_CXX20
; 2176 :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Orphan_ran

; 2177 :             _Orphan_range_unlocked(_First, _Last);

	mov	r8, QWORD PTR _Last$[rbp]
	mov	rdx, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_unlocked

; 2178 :         } else

	jmp	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 2179 : #endif // _HAS_CXX20
; 2180 :         {
; 2181 :             _Orphan_range_locked(_First, _Last);

	mov	r8, QWORD PTR _Last$[rbp]
	mov	rdx, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
$LN3@Orphan_ran:

; 2182 :         }
; 2183 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_range@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
_TEXT	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
_First$ = 264
_Last$ = 272
?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked, COMDAT

; 2168 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2169 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
	npad	1

; 2170 :         _Orphan_range_unlocked(_First, _Last);

	mov	r8, QWORD PTR _Last$[rbp]
	mov	rdx, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_unlocked
	npad	1

; 2171 :     }

	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
_First$ = 264
_Last$ = 272
?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA PROC ; `std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0??_Orphan_range_locked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z@4HA ENDP ; `std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_locked'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z
_TEXT	SEGMENT
_Pnext$ = 8
_Pnextptr$1 = 40
_Temp$2 = 72
this$ = 320
_First$ = 328
_Last$ = 336
?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_unlocked, COMDAT

; 2154 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2155 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	mov	QWORD PTR _Pnext$[rbp], rax
$LN2@Orphan_ran:

; 2156 :         while (*_Pnext) {

	mov	rax, QWORD PTR _Pnext$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Orphan_ran

; 2157 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnextptr$1[rbp], rax

; 2158 :             const auto _Temp     = *_Pnext;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Temp$2[rbp], rax

; 2159 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

	mov	rax, QWORD PTR _First$[rbp]
	cmp	QWORD PTR _Pnextptr$1[rbp], rax
	jb	SHORT $LN6@Orphan_ran
	mov	rax, QWORD PTR _Pnextptr$1[rbp]
	cmp	QWORD PTR _Last$[rbp], rax
	jae	SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2160 :                 _Pnext = &_Temp->_Mynextiter;

	mov	rax, QWORD PTR _Temp$2[rbp]
	add	rax, 8
	mov	QWORD PTR _Pnext$[rbp], rax

; 2161 :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2162 :                 _Temp->_Myproxy = nullptr;

	mov	rax, QWORD PTR _Temp$2[rbp]
	mov	QWORD PTR [rax], 0

; 2163 :                 *_Pnext         = _Temp->_Mynextiter;

	mov	rax, QWORD PTR _Pnext$[rbp]
	mov	rcx, QWORD PTR _Temp$2[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx
$LN5@Orphan_ran:

; 2164 :             }
; 2165 :         }

	jmp	SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 2166 :     }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_range_unlocked@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAXPEAVthread@2@0@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Xlength, COMDAT

; 2145 :     [[noreturn]] static void _Xlength() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2146 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2147 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Xlength@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 8
_My_data$ = 40
_Myfirst$ = 72
_Mylast$ = 104
_Myend$ = 136
this$ = 384
?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Tidy, COMDAT

; 2043 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2044 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 2045 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 2046 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	QWORD PTR _Myfirst$[rbp], rax

; 2047 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 2048 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 24
	mov	QWORD PTR _Myend$[rbp], rax

; 2049 : 
; 2050 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2051 : 
; 2052 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2053 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread> >

; 2054 :             _ASAN_VECTOR_REMOVE;
; 2055 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rbp]
	mov	rcx, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 4
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z ; std::allocator<std::thread>::deallocate

; 2056 : 
; 2057 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	QWORD PTR [rax], 0

; 2058 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	QWORD PTR [rax], 0

; 2059 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rbp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2060 :         }
; 2061 :     }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z
_TEXT	SEGMENT
_Al$ = 8
_My_data$ = 40
_Myfirst$ = 72
_Mylast$ = 104
_Myend$ = 136
this$ = 384
_Newvec$ = 392
_Newsize$ = 400
_Newcapacity$ = 408
?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Change_array, COMDAT

; 2021 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 2022 :         // orphan all iterators, discard old array, acquire new array
; 2023 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 2024 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 2025 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	QWORD PTR _Myfirst$[rbp], rax

; 2026 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 2027 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 24
	mov	QWORD PTR _Myend$[rbp], rax

; 2028 : 
; 2029 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2030 : 
; 2031 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2032 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@Vthread@std@@@std@@@std@@YAXPEAVthread@0@QEAV10@AEAV?$allocator@Vthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread> >

; 2033 :             _ASAN_VECTOR_REMOVE;
; 2034 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rbp]
	mov	rcx, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 4
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z ; std::allocator<std::thread>::deallocate
$LN2@Change_arr:

; 2035 :         }
; 2036 : 
; 2037 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR _Newvec$[rbp]
	mov	QWORD PTR [rax], rcx

; 2038 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rbp]
	mov	QWORD PTR [rcx], rax

; 2039 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rbp], 16
	mov	rcx, QWORD PTR _Newvec$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rbp]
	mov	QWORD PTR [rcx], rax

; 2040 :         _ASAN_VECTOR_CREATE;
; 2041 :     }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
?_Change_array@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXQEAVthread@2@_K1@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 8
_Max$ = 40
_Geometric$ = 72
this$ = 320
_Newsize$ = 328
?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Calculate_growth, COMDAT

; 1969 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 1970 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1971 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rbp]
	call	?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ; std::vector<std::thread,std::allocator<std::thread> >::capacity
	mov	QWORD PTR _Oldcapacity$[rbp], rax

; 1972 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ; std::vector<std::thread,std::allocator<std::thread> >::max_size
	mov	QWORD PTR _Max$[rbp], rax

; 1973 : 
; 1974 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rbp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rbp], rax
	jbe	SHORT $LN2@Calculate_

; 1975 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rbp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1976 :         }
; 1977 : 
; 1978 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rbp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rbp], rax

; 1979 : 
; 1980 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rbp]
	cmp	QWORD PTR _Geometric$[rbp], rax
	jae	SHORT $LN3@Calculate_

; 1981 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rbp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1982 :         }
; 1983 : 
; 1984 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rbp]
$LN1@Calculate_:

; 1985 :     }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
?_Calculate_growth@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 8
this$ = 256
?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::capacity, COMDAT

; 1885 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 1886 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1887 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	sar	rax, 4

; 1888 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?capacity@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 200
$T2 = 232
this$ = 288
?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::max_size, COMDAT

; 1880 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 1881 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEBAAEBV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::thread> >::max_size
	mov	QWORD PTR $T1[rbp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T2[rbp], rax
	lea	rdx, QWORD PTR $T1[rbp]
	lea	rcx, QWORD PTR $T2[rbp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1882 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1883 :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_end, COMDAT

; 1862 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 1863 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+16]

; 1864 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_begin, COMDAT

; 1854 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 1855 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]

; 1856 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 8
$S8$ = 36
$T4 = 260
__$ArrayPad$ = 280
this$ = 320
??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >, COMDAT

; 764  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 26
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode

; 765  :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAXXZ ; std::vector<std::thread,std::allocator<std::thread> >::_Tidy

; 766  : #if _ITERATOR_DEBUG_LEVEL != 0
; 767  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $S8$[rbp]
	call	??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::thread>
	lea	rax, QWORD PTR $S8$[rbp]
	mov	QWORD PTR _Alproxy$[rbp], rax

; 768  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	QWORD PTR $T4[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rdx, QWORD PTR $T4[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	mov	rdx, rax
	mov	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 769  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 770  :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vector
;	COMDAT ??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 196
$T2 = 228
tv83 = 248
tv69 = 248
this$ = 288
??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::thread,std::allocator<std::thread> >::vector<std::thread,std::allocator<std::thread> >, COMDAT

; 608  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__51919D19_vector
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@Vthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@Vthread@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1>::_Compressed_pair<std::allocator<std::thread>,std::_Vector_val<std::_Simple_types<std::thread> >,1><>

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv83[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@AEAAAEAV?$allocator@Vthread@std@@@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rbp]
	call	??$?0Vthread@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@Vthread@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::thread>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv83[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 610  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::thread,std::allocator<std::thread> >::vector<std::thread,std::allocator<std::thread> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 224
?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::thread> >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 738  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@Vthread@std@@@std@@@std@@SA_KAEBV?$allocator@Vthread@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::thread> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z PROC ; std::allocator<std::thread>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z	; std::_Get_size_of_n<16>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@Vthread@std@@@std@@QEAAPEAVthread@2@_K@Z ENDP ; std::allocator<std::thread>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z PROC ; std::allocator<std::thread>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 971				; 000003cbH
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 971				; 000003cbH
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@Vthread@std@@@std@@QEAAXQEAVthread@2@_K@Z ENDP ; std::allocator<std::thread>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0?$allocator@Vthread@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$allocator@Vthread@std@@@std@@QEAA@XZ PROC		; std::allocator<std::thread>::allocator<std::thread>, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$allocator@Vthread@std@@@std@@QEAA@XZ ENDP		; std::allocator<std::thread>::allocator<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z
_TEXT	SEGMENT
lock$4 = 8
tv76 = 232
__$ArrayPad$ = 240
this$ = 288
task$ = 296
?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z PROC ; thread_pool::enqueue, COMDAT

; 28   : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode

; 29   :     {
; 30   :         std::unique_lock<std::mutex> lock(queue_mutex);

	mov	edx, 16
	lea	rcx, QWORD PTR lock$4[rbp]
	call	?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 72					; 00000048H
	mov	rdx, rax
	lea	rcx, QWORD PTR lock$4[rbp]
	call	??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
	npad	1

; 31   :         tasks.push(task);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv76[rbp], rax
	mov	rdx, QWORD PTR task$[rbp]
	mov	rcx, QWORD PTR tv76[rbp]
	call	?push@?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::push
	npad	1

; 32   :     }

	lea	rcx, QWORD PTR lock$4[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>

; 33   :     condition.notify_one();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	?notify_one@condition_variable@std@@QEAAXXZ ; std::condition_variable::notify_one
	npad	1

; 34   : }

	mov	rcx, QWORD PTR task$[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z ENDP ; thread_pool::enqueue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
lock$4 = 8
tv76 = 232
__$ArrayPad$ = 240
this$ = 288
task$ = 296
?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA PROC ; `thread_pool::enqueue'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR task$[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA ENDP ; `thread_pool::enqueue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
lock$4 = 8
tv76 = 232
__$ArrayPad$ = 240
this$ = 288
task$ = 296
?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA PROC ; `thread_pool::enqueue'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR lock$4[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0??enqueue@thread_pool@@QEAAXV?$function@$$A6AXXZ@std@@@Z@4HA ENDP ; `thread_pool::enqueue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??1thread_pool@@QEAA@XZ
_TEXT	SEGMENT
lock$4 = 8
<range>$L0$5 = 56
<begin>$L0$6 = 88
<end>$L0$7 = 120
worker$8 = 152
__$ArrayPad$ = 360
this$ = 400
??1thread_pool@@QEAA@XZ PROC				; thread_pool::~thread_pool, COMDAT

; 12   : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 408				; 00000198H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+440]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode

; 13   :     {
; 14   :         std::unique_lock<std::mutex> lock(queue_mutex);

	mov	edx, 16
	lea	rcx, QWORD PTR lock$4[rbp]
	call	?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 72					; 00000048H
	mov	rdx, rax
	lea	rcx, QWORD PTR lock$4[rbp]
	call	??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>

; 15   :         stop = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+224], 1

; 16   :     }

	lea	rcx, QWORD PTR lock$4[rbp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>

; 17   :     condition.notify_all();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	?notify_all@condition_variable@std@@QEAAXXZ ; std::condition_variable::notify_all

; 18   :     for (std::thread& worker : workers)

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR <range>$L0$5[rbp], rax
	mov	rcx, QWORD PTR <range>$L0$5[rbp]
	call	?_Unchecked_begin@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_begin
	mov	QWORD PTR <begin>$L0$6[rbp], rax
	mov	rcx, QWORD PTR <range>$L0$5[rbp]
	call	?_Unchecked_end@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAAPEAVthread@2@XZ ; std::vector<std::thread,std::allocator<std::thread> >::_Unchecked_end
	mov	QWORD PTR <end>$L0$7[rbp], rax
	jmp	SHORT $LN4@thread_poo
$LN2@thread_poo:
	mov	rax, QWORD PTR <begin>$L0$6[rbp]
	add	rax, 16
	mov	QWORD PTR <begin>$L0$6[rbp], rax
$LN4@thread_poo:
	mov	rax, QWORD PTR <end>$L0$7[rbp]
	cmp	QWORD PTR <begin>$L0$6[rbp], rax
	je	SHORT $LN3@thread_poo
	mov	rax, QWORD PTR <begin>$L0$6[rbp]
	mov	QWORD PTR worker$8[rbp], rax

; 19   :     {
; 20   :         if (worker.joinable())

	mov	rcx, QWORD PTR worker$8[rbp]
	call	?joinable@thread@std@@QEBA_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@thread_poo

; 21   :         {
; 22   :             worker.join();

	mov	rcx, QWORD PTR worker$8[rbp]
	call	?join@thread@std@@QEAAXXZ		; std::thread::join
$LN5@thread_poo:

; 23   :         }
; 24   :     }

	jmp	SHORT $LN2@thread_poo
$LN3@thread_poo:

; 25   : }

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	??1condition_variable@std@@QEAA@XZ	; std::condition_variable::~condition_variable
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??1mutex@std@@QEAA@XZ
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1thread_pool@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	npad	1
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+376]
	pop	rdi
	pop	rbp
	ret	0
??1thread_pool@@QEAA@XZ ENDP				; thread_pool::~thread_pool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ??0thread_pool@@QEAA@_K@Z
_TEXT	SEGMENT
i$1 = 8
$T2 = 232
tv95 = 248
this$ = 288
num_threads$ = 296
??0thread_pool@@QEAA@_K@Z PROC				; thread_pool::thread_pool, COMDAT

; 4    : {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ; std::vector<std::thread,std::allocator<std::thread> >::vector<std::thread,std::allocator<std::thread> >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ ; std::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::queue<std::function<void __cdecl(void)>,std::deque<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0mutex@std@@QEAA@XZ			; std::mutex::mutex
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 152				; 00000098H
	mov	rcx, rax
	call	??0condition_variable@std@@QEAA@XZ	; std::condition_variable::condition_variable
	npad	1

; 3    : thread_pool::thread_pool(size_t num_threads) : stop(false)

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+224], 0

; 5    :     for (size_t i = 0; i < num_threads; ++i)

	mov	QWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@thread_poo
$LN2@thread_poo:
	mov	rax, QWORD PTR i$1[rbp]
	inc	rax
	mov	QWORD PTR i$1[rbp], rax
$LN4@thread_poo:
	mov	rax, QWORD PTR num_threads$[rbp]
	cmp	QWORD PTR i$1[rbp], rax
	jae	SHORT $LN3@thread_poo

; 6    :     {
; 7    :         workers.emplace_back([this] { this->worker(); });

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv95[rbp], rax
	mov	rdx, QWORD PTR this$[rbp]
	lea	rcx, QWORD PTR $T2[rbp]
	call	??0<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@QEAA@PEAV1@@Z ; `thread_pool::thread_pool'::`4'::<lambda_1>::<lambda_1>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv95[rbp]
	call	??$emplace_back@V<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA?A_T$$QEAV<lambda_1>@?3???0thread_pool@@QEAA@_K@Z@@Z ; std::vector<std::thread,std::allocator<std::thread> >::emplace_back<`thread_pool::thread_pool'::`4'::<lambda_1> >

; 8    :     }

	jmp	SHORT $LN2@thread_poo
$LN3@thread_poo:

; 9    : }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??0thread_pool@@QEAA@_K@Z ENDP				; thread_pool::thread_pool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
i$1 = 8
$T2 = 232
tv95 = 248
this$ = 288
num_threads$ = 296
?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA PROC		; `thread_pool::thread_pool'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$vector@Vthread@std@@V?$allocator@Vthread@std@@@2@@std@@QEAA@XZ ; std::vector<std::thread,std::allocator<std::thread> >::~vector<std::thread,std::allocator<std::thread> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0thread_pool@@QEAA@_K@Z@4HA ENDP		; `thread_pool::thread_pool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
i$1 = 8
$T2 = 232
tv95 = 248
this$ = 288
num_threads$ = 296
?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA PROC		; `thread_pool::thread_pool'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 32					; 00000020H
	call	??1?$queue@V?$function@$$A6AXXZ@std@@V?$deque@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@2@@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0???0thread_pool@@QEAA@_K@Z@4HA ENDP		; `thread_pool::thread_pool'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
i$1 = 8
$T2 = 232
tv95 = 248
this$ = 288
num_threads$ = 296
?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA PROC		; `thread_pool::thread_pool'::`1'::dtor$2
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1mutex@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$2@?0???0thread_pool@@QEAA@_K@Z@4HA ENDP		; `thread_pool::thread_pool'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
i$1 = 8
$T2 = 232
tv95 = 248
this$ = 288
num_threads$ = 296
?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA PROC		; `thread_pool::thread_pool'::`1'::dtor$3
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	??1condition_variable@std@@QEAA@XZ	; std::condition_variable::~condition_variable
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$3@?0???0thread_pool@@QEAA@_K@Z@4HA ENDP		; `thread_pool::thread_pool'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 224
classSize$ = 232
?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z PROC ; std::unique_lock<std::mutex>::__autoclassinit2, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rbp, rsp
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR classSize$[rbp]
	rep stosb
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__autoclassinit2@?$unique_lock@Vmutex@std@@@std@@QEAAX_K@Z ENDP ; std::unique_lock<std::mutex>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ
_TEXT	SEGMENT
this$ = 224
?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ PROC ; std::unique_lock<std::mutex>::mutex, COMDAT

; 260  :     _NODISCARD _Mutex* mutex() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 261  :         return _Pmtx;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]

; 262  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ ENDP ; std::unique_lock<std::mutex>::mutex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ PROC		; std::unique_lock<std::mutex>::~unique_lock<std::mutex>, COMDAT

; 193  :     ~unique_lock() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 194  :         if (_Owns) {

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN2@unique_loc

; 195  :             _Pmtx->unlock();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	?unlock@_Mutex_base@std@@QEAAXXZ	; std::_Mutex_base::unlock
$LN2@unique_loc:

; 196  :         }
; 197  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$unique_lock@Vmutex@std@@@std@@QEAA@XZ ENDP		; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z
_TEXT	SEGMENT
this$ = 224
_Mtx$ = 232
??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z PROC ; std::unique_lock<std::mutex>::unique_lock<std::mutex>, COMDAT

; 147  :         : _Pmtx(_STD addressof(_Mtx)), _Owns(false) { // construct and lock

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode
	mov	rcx, QWORD PTR _Mtx$[rbp]
	call	??$addressof@Vmutex@std@@@std@@YAPEAVmutex@0@AEAV10@@Z ; std::addressof<std::mutex>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+8], 0

; 148  :         _Pmtx->lock();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	?lock@_Mutex_base@std@@QEAAXXZ		; std::_Mutex_base::lock

; 149  :         _Owns = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+8], 1

; 150  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$unique_lock@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ENDP ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ
_TEXT	SEGMENT
this$ = 224
?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ PROC ; std::condition_variable::_Mycnd, COMDAT

; 642  :     _Cnd_t _Mycnd() noexcept { // get pointer to _Cnd_internal_imp_t inside _Cnd_storage

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 643  :         return reinterpret_cast<_Cnd_t>(&_Cnd_storage);

	mov	rax, QWORD PTR this$[rbp]

; 644  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ENDP ; std::condition_variable::_Mycnd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z
_TEXT	SEGMENT
tv80 = 192
tv78 = 200
this$ = 240
_Lck$ = 248
?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z PROC ; std::condition_variable::wait, COMDAT

; 561  :     void wait(unique_lock<mutex>& _Lck) noexcept /* strengthened */ { // wait for signal

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 562  :         // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow
; 563  :         _Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx());

	mov	rcx, QWORD PTR _Lck$[rbp]
	call	?mutex@?$unique_lock@Vmutex@std@@@std@@QEBAPEAV02@XZ ; std::unique_lock<std::mutex>::mutex
	mov	rcx, rax
	call	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	mov	QWORD PTR tv80[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	mov	QWORD PTR tv78[rbp], rax
	mov	rdx, QWORD PTR tv80[rbp]
	mov	rcx, QWORD PTR tv78[rbp]
	call	_Cnd_wait

; 564  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?wait@condition_variable@std@@QEAAXAEAV?$unique_lock@Vmutex@std@@@2@@Z ENDP ; std::condition_variable::wait
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?notify_all@condition_variable@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?notify_all@condition_variable@std@@QEAAXXZ PROC	; std::condition_variable::notify_all, COMDAT

; 557  :     void notify_all() noexcept { // wake up all waiters

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 558  :         _Cnd_broadcast(_Mycnd());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	mov	rcx, rax
	call	_Cnd_broadcast

; 559  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?notify_all@condition_variable@std@@QEAAXXZ ENDP	; std::condition_variable::notify_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?notify_one@condition_variable@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?notify_one@condition_variable@std@@QEAAXXZ PROC	; std::condition_variable::notify_one, COMDAT

; 553  :     void notify_one() noexcept { // wake up one waiter

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 554  :         _Cnd_signal(_Mycnd());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	mov	rcx, rax
	call	_Cnd_signal

; 555  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?notify_one@condition_variable@std@@QEAAXXZ ENDP	; std::condition_variable::notify_one
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??1condition_variable@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1condition_variable@std@@QEAA@XZ PROC			; std::condition_variable::~condition_variable, COMDAT

; 546  :     ~condition_variable() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 547  :         _Cnd_destroy_in_situ(_Mycnd());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	mov	rcx, rax
	call	_Cnd_destroy_in_situ

; 548  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1condition_variable@std@@QEAA@XZ ENDP			; std::condition_variable::~condition_variable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??0condition_variable@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0condition_variable@std@@QEAA@XZ PROC			; std::condition_variable::condition_variable, COMDAT

; 542  :     condition_variable() noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 543  :         _Cnd_init_in_situ(_Mycnd());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mycnd@condition_variable@std@@AEAAPEAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	mov	rcx, rax
	call	_Cnd_init_in_situ

; 544  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0condition_variable@std@@QEAA@XZ ENDP			; std::condition_variable::condition_variable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1mutex@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1mutex@std@@QEAA@XZ PROC				; std::mutex::~mutex, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Mutex_base@std@@QEAA@XZ		; std::_Mutex_base::~_Mutex_base
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1mutex@std@@QEAA@XZ ENDP				; std::mutex::~mutex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??0mutex@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0mutex@std@@QEAA@XZ PROC				; std::mutex::mutex, COMDAT

; 104  :     mutex() noexcept = default;

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Mutex_base@std@@QEAA@H@Z		; std::_Mutex_base::_Mutex_base
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0mutex@std@@QEAA@XZ ENDP				; std::mutex::mutex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ
_TEXT	SEGMENT
this$ = 224
?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ PROC ; std::_Mutex_base::_Mymtx, COMDAT

; 97   :     _Mtx_t _Mymtx() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 98   :         return &_Mtx_storage;

	mov	rax, QWORD PTR this$[rbp]

; 99   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ENDP ; std::_Mutex_base::_Mymtx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ
_TEXT	SEGMENT
this$ = 224
?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ PROC ; std::_Mutex_base::_Verify_ownership_levels, COMDAT

; 81   :     _NODISCARD_TRY_CHANGE_STATE bool _Verify_ownership_levels() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 82   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+76], 2147483647		; 7fffffffH
	jne	SHORT $LN2@Verify_own

; 83   :             // only occurs for recursive mutexes (N4950 [thread.mutex.recursive]/3)
; 84   :             --_Mtx_storage._Count;

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax+76]
	dec	eax
	mov	rcx, QWORD PTR this$[rbp]
	mov	DWORD PTR [rcx+76], eax

; 85   :             return false;

	xor	al, al
	jmp	SHORT $LN1@Verify_own
$LN2@Verify_own:

; 86   :         }
; 87   : 
; 88   :         return true;

	mov	al, 1
$LN1@Verify_own:

; 89   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ ENDP ; std::_Mutex_base::_Verify_ownership_levels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?unlock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::unlock, COMDAT

; 74   :     void unlock() noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 75   :         _Mtx_unlock(_Mymtx());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	mov	rcx, rax
	call	_Mtx_unlock

; 76   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?unlock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?lock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::lock, COMDAT

; 55   :     void lock() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 56   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	mov	rcx, rax
	call	_Mtx_lock
	test	eax, eax
	je	SHORT $LN2@lock

; 57   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 58   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN2@lock:

; 59   :         }
; 60   : 
; 61   :         if (!_Verify_ownership_levels()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ ; std::_Mutex_base::_Verify_ownership_levels
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@lock

; 62   :             // only occurs for recursive mutexes (N4950 [thread.mutex.recursive]/3)
; 63   :             // POSIX specifies EAGAIN in the corresponding situation:
; 64   :             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html
; 65   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN3@lock:
$LN4@lock:

; 66   :         }
; 67   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?lock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??1_Mutex_base@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1_Mutex_base@std@@QEAA@XZ PROC			; std::_Mutex_base::~_Mutex_base, COMDAT

; 48   :     ~_Mutex_base() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode

; 49   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	mov	rcx, rax
	call	_Mtx_destroy_in_situ

; 50   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1_Mutex_base@std@@QEAA@XZ ENDP			; std::_Mutex_base::~_Mutex_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\mutex
;	COMDAT ??0_Mutex_base@std@@QEAA@H@Z
_TEXT	SEGMENT
tv80 = 192
this$ = 240
_Flags$ = 248
??0_Mutex_base@std@@QEAA@H@Z PROC			; std::_Mutex_base::_Mutex_base, COMDAT

; 43   :     _Mutex_base(int _Flags = 0) noexcept {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C1D7C16D_mutex
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 24
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 48					; 00000030H
	rep stosb
	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+72], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax+76], 0

; 44   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	eax, DWORD PTR _Flags$[rbp]
	or	eax, 2
	mov	DWORD PTR tv80[rbp], eax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	mov	ecx, DWORD PTR tv80[rbp]
	mov	edx, ecx
	mov	rcx, rax
	call	_Mtx_init_in_situ

; 45   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??0_Mutex_base@std@@QEAA@H@Z ENDP			; std::_Mutex_base::_Mutex_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 272
_Val$ = 280
_New_val$ = 288
??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z PROC ; std::exchange<_Thrd_t,_Thrd_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 272				; 00000110H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+312]
	lea	rcx, OFFSET FLAT:__394B8783_utility
	call	__CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdi, QWORD PTR __$ReturnAddress$[rbp]
	mov	rsi, QWORD PTR _Val$[rbp]
	mov	ecx, 16
	rep movsb

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdi, QWORD PTR _Val$[rbp]
	mov	rsi, QWORD PTR _New_val$[rbp]
	mov	ecx, 16
	rep movsb

; 764  :     return _Old_val;

	mov	rax, QWORD PTR __$ReturnAddress$[rbp]

; 765  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+240]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z ENDP ; std::exchange<_Thrd_t,_Thrd_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gthread@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gthread@std@@QEAAPEAXI@Z PROC			; std::thread::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1thread@std@@QEAA@XZ			; std::thread::~thread
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gthread@std@@QEAAPEAXI@Z ENDP			; std::thread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ?join@thread@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 200
$T2 = 256
this$ = 320
?join@thread@std@@QEAAXXZ PROC				; std::thread::join, COMDAT

; 124  :     void join() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 320				; 00000140H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 125  :         if (!joinable()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?joinable@thread@std@@QEBA_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@join

; 126  :             _Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	ecx, 1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN2@join:

; 127  :         }
; 128  : 
; 129  :         if (_Thr._Id == _Thrd_id()) {

	call	_Thrd_id
	mov	rcx, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@join

; 130  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN3@join:

; 131  :         }
; 132  : 
; 133  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_result::_Success) {

	lea	rax, QWORD PTR $T2[rbp]
	mov	rdi, rax
	mov	rsi, QWORD PTR this$[rbp]
	mov	ecx, 16
	rep movsb
	xor	edx, edx
	lea	rcx, QWORD PTR $T2[rbp]
	call	_Thrd_join
	test	eax, eax
	je	SHORT $LN4@join

; 134  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

	mov	ecx, 2
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN4@join:

; 135  :         }
; 136  : 
; 137  :         _Thr = {};

	lea	rax, QWORD PTR $T1[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	lea	rax, QWORD PTR $T1[rbp]
	mov	rdi, QWORD PTR this$[rbp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN5@join:

; 138  :     }

	lea	rsp, QWORD PTR [rbp+288]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?join@thread@std@@QEAAXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ?joinable@thread@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 192
this$ = 240
?joinable@thread@std@@QEBA_NXZ PROC			; std::thread::joinable, COMDAT

; 120  :     _NODISCARD bool joinable() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 121  :         return _Thr._Id != 0;

	mov	rax, QWORD PTR this$[rbp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN3@joinable
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN4@joinable
$LN3@joinable:
	mov	DWORD PTR tv67[rbp], 0
$LN4@joinable:
	movzx	eax, BYTE PTR tv67[rbp]

; 122  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?joinable@thread@std@@QEBA_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ??0thread@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 200
$T2 = 248
this$ = 320
_Other$ = 328
??0thread@std@@QEAA@$$QEAV01@@Z PROC			; std::thread::thread, COMDAT

; 102  :     thread(thread&& _Other) noexcept : _Thr(_STD exchange(_Other._Thr, {})) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 320				; 00000140H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode
	lea	rax, QWORD PTR $T1[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR _Other$[rbp]
	lea	r8, QWORD PTR $T1[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rbp]
	call	??$exchange@U_Thrd_t@@U1@@std@@YA?AU_Thrd_t@@AEAU1@$$QEAU1@@Z ; std::exchange<_Thrd_t,_Thrd_t>
	mov	rdi, QWORD PTR this$[rbp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+288]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0thread@std@@QEAA@$$QEAV01@@Z ENDP			; std::thread::thread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\thread
;	COMDAT ??1thread@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1thread@std@@QEAA@XZ PROC				; std::thread::~thread, COMDAT

; 96   :     ~thread() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7BDF99C1_thread
	call	__CheckForDebuggerJustMyCode

; 97   :         if (joinable()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?joinable@thread@std@@QEBA_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@thread

; 98   :             _STD terminate(); // per N4950 [thread.thread.destr]/1

	call	QWORD PTR __imp_terminate
$LN3@thread:

; 99   :         }
; 100  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1thread@std@@QEAA@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = 200
tv93 = 264
tv85 = 264
this$ = 304
__formal$ = 312
_Lobj$ = 320
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT

; 238  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 304				; 00000130H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A4ED74A_xloctime
	call	__CheckForDebuggerJustMyCode

; 239  :         _Cvt = _Lobj._Getcvt();

	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
	mov	rcx, QWORD PTR this$[rbp]
	lea	rdi, QWORD PTR [rcx+44]
	mov	rsi, rax
	mov	ecx, 44					; 0000002cH
	rep movsb

; 240  : 
; 241  :         if (is_same_v<_Elem2, wchar_t>) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@Getvals

; 242  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ
	mov	rcx, rax
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 243  :             _Months =

	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ
	mov	rcx, rax
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 244  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 245  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

	lea	rcx, OFFSET FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 246  :         } else {

	jmp	$LN3@Getvals
$LN2@Getvals:

; 247  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	QWORD PTR tv85[rbp], rax
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ
	mov	rcx, QWORD PTR tv85[rbp]
	mov	r8, rcx
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 248  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	QWORD PTR tv93[rbp], rax
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ
	mov	rcx, QWORD PTR tv93[rbp]
	mov	r8, rcx
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 249  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	r8, rax
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	call	??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+32], rax
$LN3@Getvals:

; 250  :         }
; 251  :     }

	lea	rsp, QWORD PTR [rbp+272]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = 200
tv93 = 264
tv85 = 264
this$ = 304
__formal$ = 312
_Lobj$ = 320
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT

; 238  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 304				; 00000130H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A4ED74A_xloctime
	call	__CheckForDebuggerJustMyCode

; 239  :         _Cvt = _Lobj._Getcvt();

	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
	mov	rcx, QWORD PTR this$[rbp]
	lea	rdi, QWORD PTR [rcx+44]
	mov	rsi, rax
	mov	ecx, 44					; 0000002cH
	rep movsb

; 240  : 
; 241  :         if (is_same_v<_Elem2, wchar_t>) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@Getvals

; 242  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ
	mov	rcx, rax
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 243  :             _Months =

	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ
	mov	rcx, rax
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 244  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 245  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

	lea	rcx, OFFSET FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	call	?_Maklocwcs@std@@YAPEA_WPEB_W@Z		; std::_Maklocwcs
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 246  :         } else {

	jmp	$LN3@Getvals
$LN2@Getvals:

; 247  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	QWORD PTR tv85[rbp], rax
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ
	mov	rcx, QWORD PTR tv85[rbp]
	mov	r8, rcx
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 248  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	QWORD PTR tv93[rbp], rax
	mov	rcx, QWORD PTR _Lobj$[rbp]
	call	QWORD PTR __imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ
	mov	rcx, QWORD PTR tv93[rbp]
	mov	r8, rcx
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 249  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 44					; 0000002cH
	mov	r8, rax
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+32], rax
$LN3@Getvals:

; 250  :         }
; 251  :     }

	lea	rsp, QWORD PTR [rbp+272]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
_Count$ = 8
_Ptrdest$ = 40
_Ptrnext$1 = 72
_Ptr$ = 320
__formal$ = 328
__formal$ = 336
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 525  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__F83316ED_xlocale
	call	__CheckForDebuggerJustMyCode

; 526  :     // convert C string to _Elem sequence using _Cvtvec
; 527  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	strlen
	inc	rax
	mov	QWORD PTR _Count$[rbp], rax

; 528  : 
; 529  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

	mov	DWORD PTR [rsp+32], 529			; 00000211H
	lea	r9, OFFSET FLAT:??_C@_0GC@GNDJPOJH@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	r8d, 2
	mov	edx, 1
	mov	rcx, QWORD PTR _Count$[rbp]
	call	QWORD PTR __imp__calloc_dbg
	mov	QWORD PTR _Ptrdest$[rbp], rax

; 530  : 
; 531  :     if (!_Ptrdest) {

	cmp	QWORD PTR _Ptrdest$[rbp], 0
	jne	SHORT $LN5@Maklocstr

; 532  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN5@Maklocstr:

; 533  :     }
; 534  : 
; 535  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	rax, QWORD PTR _Ptrdest$[rbp]
	mov	QWORD PTR _Ptrnext$1[rbp], rax
	jmp	SHORT $LN4@Maklocstr
$LN2@Maklocstr:
	mov	rax, QWORD PTR _Count$[rbp]
	dec	rax
	mov	QWORD PTR _Count$[rbp], rax
	mov	rax, QWORD PTR _Ptrnext$1[rbp]
	inc	rax
	mov	QWORD PTR _Ptrnext$1[rbp], rax
	mov	rax, QWORD PTR _Ptr$[rbp]
	inc	rax
	mov	QWORD PTR _Ptr$[rbp], rax
$LN4@Maklocstr:
	cmp	QWORD PTR _Count$[rbp], 0
	jbe	SHORT $LN3@Maklocstr

; 536  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

	mov	rax, QWORD PTR _Ptrnext$1[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 537  :     }

	jmp	SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 538  : 
; 539  :     return _Ptrdest;

	mov	rax, QWORD PTR _Ptrdest$[rbp]
$LN6@Maklocstr:

; 540  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPEA_WPEB_W@Z
_TEXT	SEGMENT
_Count$ = 8
_Ptrdest$ = 40
_Ptr$ = 288
?_Maklocwcs@std@@YAPEA_WPEB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 71   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__66B470FA_xlocnum
	call	__CheckForDebuggerJustMyCode

; 72   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	QWORD PTR __imp_wcslen
	inc	rax
	mov	QWORD PTR _Count$[rbp], rax

; 73   : 
; 74   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

	mov	eax, DWORD PTR ?__LINE__Var@?0??_Maklocwcs@std@@YAPEA_WPEB_W@Z@4JA
	add	eax, 3
	mov	DWORD PTR [rsp+32], eax
	lea	r9, OFFSET FLAT:??_C@_0GC@OOHEPMDG@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	r8d, 2
	mov	edx, 2
	mov	rcx, QWORD PTR _Count$[rbp]
	call	QWORD PTR __imp__calloc_dbg
	mov	QWORD PTR _Ptrdest$[rbp], rax

; 75   : 
; 76   :     if (!_Ptrdest) {

	cmp	QWORD PTR _Ptrdest$[rbp], 0
	jne	SHORT $LN2@Maklocwcs

; 77   :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN2@Maklocwcs:

; 78   :     }
; 79   : 
; 80   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptrdest$[rbp]
	call	wmemcpy

; 81   :     return _Ptrdest;

	mov	rax, QWORD PTR _Ptrdest$[rbp]
$LN3@Maklocwcs:

; 82   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?_Maklocwcs@std@@YAPEA_WPEB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
_Count$ = 8
_Count1$ = 40
_Wchars$ = 72
_Ptr1$ = 104
_Bytes$ = 132
_Wc$ = 164
_Mbst1$ = 200
_Ptrdest$ = 232
_Ptrnext$ = 264
_Mbst2$ = 296
__$ArrayPad$ = 504
_Ptr$ = 544
__formal$ = 552
_Cvt$ = 560
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z PROC ; std::_Maklocstr<wchar_t>, COMDAT

; 543  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 568				; 00000238H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+600]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__F83316ED_xlocale
	call	__CheckForDebuggerJustMyCode

; 544  :     // convert C string to wchar_t sequence using _Cvtvec
; 545  :     size_t _Count;
; 546  :     size_t _Count1;
; 547  :     size_t _Wchars;
; 548  :     const char* _Ptr1;
; 549  :     int _Bytes;
; 550  :     wchar_t _Wc;
; 551  :     mbstate_t _Mbst1 = {};

	lea	rax, QWORD PTR _Mbst1$[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 552  : 
; 553  :     _Count1 = _CSTD strlen(_Ptr) + 1;

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	strlen
	inc	rax
	mov	QWORD PTR _Count1$[rbp], rax

; 554  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

	mov	rax, QWORD PTR _Count1$[rbp]
	mov	QWORD PTR _Count$[rbp], rax
	mov	QWORD PTR _Wchars$[rbp], 0
	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR _Ptr1$[rbp], rax
	jmp	SHORT $LN4@Maklocstr
$LN2@Maklocstr:
	movsxd	rax, DWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rbp], rax
	movsxd	rax, DWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Ptr1$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr1$[rbp], rax
	mov	rax, QWORD PTR _Wchars$[rbp]
	inc	rax
	mov	QWORD PTR _Wchars$[rbp], rax
$LN4@Maklocstr:
	cmp	QWORD PTR _Count$[rbp], 0
	jbe	SHORT $LN3@Maklocstr

; 555  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

	mov	rax, QWORD PTR _Cvt$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR _Mbst1$[rbp]
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr1$[rbp]
	lea	rcx, QWORD PTR _Wc$[rbp]
	call	_Mbrtowc
	mov	DWORD PTR _Bytes$[rbp], eax
	cmp	DWORD PTR _Bytes$[rbp], 0
	jg	SHORT $LN8@Maklocstr

; 556  :             break;

	jmp	SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 557  :         }
; 558  :     }

	jmp	SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 559  : 
; 560  :     ++_Wchars; // count terminating nul

	mov	rax, QWORD PTR _Wchars$[rbp]
	inc	rax
	mov	QWORD PTR _Wchars$[rbp], rax

; 561  : 
; 562  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

	mov	DWORD PTR [rsp+32], 562			; 00000232H
	lea	r9, OFFSET FLAT:??_C@_0GC@GNDJPOJH@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	r8d, 2
	mov	edx, 2
	mov	rcx, QWORD PTR _Wchars$[rbp]
	call	QWORD PTR __imp__calloc_dbg
	mov	QWORD PTR _Ptrdest$[rbp], rax

; 563  : 
; 564  :     if (!_Ptrdest) {

	cmp	QWORD PTR _Ptrdest$[rbp], 0
	jne	SHORT $LN9@Maklocstr

; 565  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN9@Maklocstr:

; 566  :     }
; 567  : 
; 568  :     wchar_t* _Ptrnext = _Ptrdest;

	mov	rax, QWORD PTR _Ptrdest$[rbp]
	mov	QWORD PTR _Ptrnext$[rbp], rax

; 569  :     mbstate_t _Mbst2  = {};

	lea	rax, QWORD PTR _Mbst2$[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 570  : 
; 571  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

	jmp	SHORT $LN7@Maklocstr
$LN5@Maklocstr:
	movsxd	rax, DWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rbp], rax
	movsxd	rax, DWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr$[rbp], rax
	mov	rax, QWORD PTR _Wchars$[rbp]
	dec	rax
	mov	QWORD PTR _Wchars$[rbp], rax
	mov	rax, QWORD PTR _Ptrnext$[rbp]
	add	rax, 2
	mov	QWORD PTR _Ptrnext$[rbp], rax
$LN7@Maklocstr:
	cmp	QWORD PTR _Wchars$[rbp], 0
	jbe	SHORT $LN6@Maklocstr

; 572  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

	mov	rax, QWORD PTR _Cvt$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR _Mbst2$[rbp]
	mov	r8, QWORD PTR _Count1$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptrnext$[rbp]
	call	_Mbrtowc
	mov	DWORD PTR _Bytes$[rbp], eax
	cmp	DWORD PTR _Bytes$[rbp], 0
	jg	SHORT $LN10@Maklocstr

; 573  :             break;

	jmp	SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 574  :         }
; 575  :     }

	jmp	$LN5@Maklocstr
$LN6@Maklocstr:

; 576  : 
; 577  :     *_Ptrnext = L'\0';

	xor	eax, eax
	mov	rcx, QWORD PTR _Ptrnext$[rbp]
	mov	WORD PTR [rcx], ax

; 578  : 
; 579  :     return _Ptrdest;

	mov	rax, QWORD PTR _Ptrdest$[rbp]
$LN11@Maklocstr:

; 580  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+520]
	pop	rdi
	pop	rbp
	ret	0
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ENDP ; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 200
_Obj$ = 256
<_Args_0>$ = 264
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81056E89_xutility
	call	__CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, rax
	call	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>

; 252  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR <_Args_0>$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN3@Construct_:

; 256  :     }
; 257  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__394B8783_utility
	call	__CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR _New_val$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 764  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rbp]

; 765  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 8
$T2 = 228
this$ = 288
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@Orphan_all

; 1371 :         return;

	jmp	SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	QWORD PTR $T2[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	mov	QWORD PTR _Pnext$1[rbp], rax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	rax, QWORD PTR _Pnext$1[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
	cmp	QWORD PTR _Pnext$1[rbp], 0
	je	SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

	mov	rax, QWORD PTR _Pnext$1[rbp]
	mov	QWORD PTR [rax], 0

; 1377 :     }

	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Orphan_all

; 1384 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1385 :     } else

	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN3@Orphan_all:

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 1199 : 
; 1200 :     _Container_base12(const _Container_base12&)            = delete;
; 1201 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1202 : 
; 1203 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1204 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1205 : 
; 1206 :     template <class _Alloc>
; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1209 :         _Construct_in_place(*_New_proxy, this);
; 1210 :         _Myproxy            = _New_proxy;
; 1211 :         _New_proxy->_Mycont = this;
; 1212 :     }
; 1213 : 
; 1214 :     template <class _Alloc>
; 1215 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1216 :         // pre: no iterators refer to the existing proxy
; 1217 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1218 :         _Construct_in_place(*_New_proxy, this);
; 1219 :         _New_proxy->_Mycont = this;
; 1220 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1221 :     }
; 1222 : 
; 1223 :     _Container_proxy* _Myproxy = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 224
_Mycont_$ = 232
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Mycont_$[rbp]
	mov	QWORD PTR [rax], rcx

; 1191 : 
; 1192 :     const _Container_base12* _Mycont       = nullptr;
; 1193 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 8
_Ptr_container$ = 40
_Min_back_shift$ = 72
_Back_shift$ = 104
_Ptr$ = 352
_Bytes$ = 360
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 47					; 0000002fH
	mov	rcx, QWORD PTR _Bytes$[rbp]
	mov	QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr_user$[rbp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN14@Adjust_man
	jmp	SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 9
	lea	rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rcx
	xor	r9d, r9d
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
	xor	eax, eax
$LN19@Adjust_man:
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 9
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN15@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // ^^^ !defined(_DEBUG) ^^^
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptr_container$[rbp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rbp], 16
	jb	SHORT $LN16@Adjust_man
	cmp	QWORD PTR _Back_shift$[rbp], 47		; 0000002fH
	ja	SHORT $LN16@Adjust_man
	jmp	SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 19
	lea	rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rcx
	xor	r9d, r9d
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
	xor	eax, eax
$LN20@Adjust_man:
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 19
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN17@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	$LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptr_container$[rbp]
	mov	QWORD PTR [rax], rcx

; 175  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 224
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 85   :         void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__53DEE440_xmemory
	call	__CheckForDebuggerJustMyCode

; 86   :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	??2@YAPEAX_K@Z				; operator new

; 87   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 635  :     _NODISCARD static constexpr long long(max)() noexcept {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1C3CEDF9_limits
	call	__CheckForDebuggerJustMyCode

; 636  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 637  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
;	COMDAT wmemcpy
_TEXT	SEGMENT
_S1$ = 224
_S2$ = 232
_N$ = 240
wmemcpy	PROC						; COMDAT

; 234  :     {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3FCAD62E_wchar@h
	call	__CheckForDebuggerJustMyCode

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rax, QWORD PTR _N$[rbp]
	shl	rax, 1
	mov	r8, rax
	mov	rdx, QWORD PTR _S2$[rbp]
	mov	rcx, QWORD PTR _S1$[rbp]
	call	memcpy

; 237  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
wmemcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 200
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 330  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__22DBD04C_exception
	call	__CheckForDebuggerJustMyCode

; 331  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rbp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rbp]
	call	_CxxThrowException
$LN2@Throw_bad_:

; 332  : }

	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode

; 140  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc

; 141  :     {

	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 142  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 224
_Message$ = 232
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode

; 129  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception

; 130  :     {

	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 131  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 192
this$ = 240
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rbp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rbp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rbp]

; 96   :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy

; 91   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
_Other$ = 232
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 71   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rbp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy

; 74   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 224
_Message$ = 232
__formal$ = 240
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9FD3D380_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 65   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 67   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Message$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 68   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 182  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__81223BB7_xtr1common
	call	__CheckForDebuggerJustMyCode

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 224
_Where$ = 232
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__50BF2FAA_vcruntime_new@h
	call	__CheckForDebuggerJustMyCode

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	rax, QWORD PTR _Where$[rbp]

; 171  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
__formal$ = 240
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\c32\source\repos\PB\PB\thread_pool.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__870AB2AE_thread_pool@cpp
	call	__CheckForDebuggerJustMyCode
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
